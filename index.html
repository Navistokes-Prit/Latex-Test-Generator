<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LaTeX Test Builder</title>

  <link rel="stylesheet" href="style_pro.css">

  <!-- SortableJS for drag-and-drop -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
</head>

<body>

  <!-- HOME SCREEN -->
  <div id="homeScreen" class="panel" style="max-width:1000px; margin:20px auto;">
    <div class="hd">
      <div class="title">LaTeX Test Builder</div>
    </div>

    <div class="bd">
      <div class="btnrow" style="margin-bottom:12px;">
        <button class="ok" id="btnGoNew">Generate New</button>
        <button id="btnGoImport">Generate from LaTeX</button>
      </div>

      <div id="importArea" style="display:none;">
        <div class="field">
          <label>Paste LaTeX generated by this tool</label>
          <textarea
            id="importLatex"
            spellcheck="false"
            style="min-height:220px;"
            placeholder="Paste the LaTeX here (must include the \begin{samepage} blocks)."
          ></textarea>

          <div class="small muted">
            Import assumes the structure produced by this builder: each question wrapped in samepage, with choices/numbox/tcolorbox patterns.
          </div>
        </div>

        <div class="btnrow">
          <button class="primary" id="btnDoImport">Import and Open Builder</button>
          <button id="btnCancelImport">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- BUILDER SCREEN -->
  <div id="builderScreen" style="display:none;">
    <header>
      <h1>Exam (LaTeX) Test Builder</h1>
      <p>Client-side tool: build questions, reorder/shuffle, and copy/paste LaTeX into Overleaf.</p>
    </header>

    <div class="app">
  <!-- LEFT: Question list -->
  <div class="panel" id="leftPanel">
    <div class="hd">
      <div class="title">Questions</div>
      <div class="muted" id="qCount">0</div>
    </div>

    <div class="bd">
      <div class="btnrow" style="margin-bottom:10px;">
        <button class="btn-add" id="btnAddMC">Add MC</button>
        <button class="btn-add" id="btnAddNum">Add Numeric</button>
        <button class="btn-add" id="btnAddWritten">Add Written</button>
        <button class="btn-add" id="btnAddInfo">Add Info</button>
        <button class="btn-shuffle" id="btnShuffleSelected">Shuffle Selected</button>
        <button class="btn-shuffle" id="btnShuffleAll">Shuffle All</button>
        <button class="btn-shuffle" id="btnShuffleWithinGroups">Shuffle Within Groups</button>
        <button class="btn-group" id="btnGroupSelected">Group Selected</button>
        <button class="btn-group" id="btnUngroupSelected">Ungroup Selected</button>
        <button id="btnClearSaved">Clear Saved</button>
      </div>

      <div class="small">Drag the handle on a question card to reorder.</div>
      <div class="hr"></div>
      <div class="qlist" id="qList"></div>
    </div>
  </div>

  <!-- RIGHT: Editor + Output (single grid item; fixes layout push-down) -->
  <div class="panel" id="rightPanel">
    <div class="hd">
      <div class="title">Editor & Output</div>

      <div class="btnrow">
        <label class="small muted" style="display:flex; align-items:center; gap:8px; margin-right:10px;">
          Format:
          <select id="docMode" style="width:auto; min-width:140px;">
            <option value="test" selected>Test</option>
            <option value="quiz">Quiz</option>
          </select>
        </label>

        <button class="ok" id="btnGenerate">Generate LaTeX</button>
        <button id="btnCopy">Copy LaTeX</button>
        <button id="btnSaveKey">Save Key Snapshot</button>
        <button id="btnShowShuffleMap">Show Shuffle Map</button>
      </div>
    </div>

  <div class="bd">
  <div class="grid2">
    <!-- LEFT COLUMN: Test settings + Question editor -->
    <div>
      <div class="field">
        <label>Test name (Title page)</label>
        <input type="text" id="testName" placeholder="e.g., Unit 3 Test" />
      </div>

      <div class="field">
        <label>Grade and Subject</label>
        <input type="text" id="gradeSubject" placeholder="e.g., Grade 10 Science" />
      </div>

      <div class="field">
        <label>Header image filename (in Overleaf images/ folder)</label>
        <input type="text" id="headerImage" value="Stem Header.png" />
        <div class="small">
          Overleaf: put the image inside <code>images/</code>. Your LaTeX already has
          <code>\graphicspath{ {./images/} }</code>.
        </div>
      </div>

      <div class="field">
        <label>Instructions (one per line)</label>
        <textarea id="instructions" placeholder="No calculators&#10;Show all work"></textarea>
      </div>

      <div class="hr"></div>

      <!-- Question editor -->
      <div class="field">
        <label>Selected Question</label>
        <div class="small" id="selectedInfo">No question selected. Click a question card on the left.</div>
      </div>

      <div id="editorArea" style="display:none;">
        <div class="grid2">
          <div class="field">
            <label>Type</label>
            <select id="qType">
              <option value="multiple_choice">Multiple Choice</option>
              <option value="numeric">Numeric Response</option>
              <option value="written">Written Response</option>
              <option value="info">Info Box</option>
            </select>
          </div>

          <div class="field">
            <label>Points (optional)</label>
            <input type="number" id="qPoints" min="0" step="1" placeholder="e.g., 3" />
          </div>
        </div>

        <div class="field">
          <label>Question prompt (LaTeX allowed)</label>
          <textarea id="qPrompt" placeholder="Type the question here..."></textarea>
        </div>

        <div class="btnrow" style="margin-top:8px;">
          <button type="button" id="btnOpenTableBuilder">Table Builder</button>
          <button type="button" id="btnOpenGraphBuilder">Graph Builder</button>
        </div>

        <div class="field">
          <label>Image filename(s) (optional, one per line; must exist in images/ folder)</label>
          <textarea id="qImages" placeholder="diagram1.png&#10;photo2.jpg"></textarea>
          <div class="small">
            Each will be inserted as <code>\includegraphics{...}</code> above the question text.
          </div>
        </div>

        <!-- Numeric-only fields -->
        <div id="numericArea" style="display:none;">
          <div class="grid2">
            <div class="field">
              <label>Numeric answer (shown only when you compile with \printanswers)</label>
              <input type="text" id="numAnswer" placeholder="e.g., 9.8 m/s^2" />
            </div>
          </div>
        </div>

        <div id="mcArea">
          <div class="field">
            <label style="display:block;">Multiple choice options (4) and correct answer</label>
            <div class="choices" id="mcChoices" style="margin-top:10px;"></div>
            <div class="small">
              Use this to create a matrix-style choice table and insert it into the prompt or a choice.
            </div>
          </div>
        </div>

        <div class="field" id="mcColumnsField">
          <label>Answer choice columns</label>
          <select id="mcColumns">
            <option value="1">1 column</option>
            <option value="2">2 columns</option>
            <option value="4">4 columns</option>
          </select>
        </div>

        <div class="btnrow">
          <button class="primary" id="btnSave">Apply Changes</button>
          <button class="danger" id="btnDelete">Delete Question</button>
          <button id="btnDuplicate">Duplicate</button>
        </div>
      </div>
    </div>

    <!-- RIGHT COLUMN: Output -->
    <div class="outwrap">
      <div class="field">
        <label>Generated LaTeX (.tex)</label>
        <textarea id="latexOut" spellcheck="false" placeholder="Click “Generate LaTeX” to populate..."></textarea>
      </div>

      <div class="field">
        <label>Mapping / Answer Key (for your reference)</label>
        <div id="mappingOut" class="panel" style="border-radius:10px; padding:10px; background: var(--panel2); border:1px solid var(--border);">
          <div class="small muted">Generate LaTeX to refresh mappings.</div>
        </div>
        <div class="small">This mapping is not inserted into the student test; it is for teachers to verify shuffles/reorders.</div>
      </div>

      <div class="field">
        <label>Shuffle Tracking (Saved Key → Current Order)</label>
        <div id="shuffleMapOut" class="panel" style="border-radius:10px; padding:10px; background: var(--panel2); border:1px solid var(--border);">
          <div class="small muted">Save a key snapshot, then shuffle/reorder to see movements.</div>
        </div>
      </div>
    </div>
  </div><!-- end .grid2 -->
</div><!-- end .bd -->
  
  </div><!-- end #rightPanel -->
</div><!-- end .app -->

</div> <!-- end #builderScreen -->

<!-- Table Builder Modal -->
<div id="tableModal" class="tb-modal">
  <div class="tb-modal-card">
    <div class="tb-modal-hd">
      <div style="font-weight:600;">Table Builder</div>
      <button type="button" id="btnCloseTableModal">Close</button>
    </div>

    <div class="tb-modal-bd">
      <div class="btnrow" style="margin-bottom:10px;">
        <button type="button" id="btnAddTableCol">Add Column</button>
        <button type="button" id="btnAddTableRow">Add Row</button>
        <button type="button" id="btnRemoveTableCol">Remove Column</button>
        <button type="button" id="btnRemoveTableRow">Remove Row</button>

        <div style="margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <label class="small muted">Insert into:</label>
          <select id="tableInsertTarget">
            <option value="prompt">Question Prompt</option>
            <option value="choice0">Choice A</option>
            <option value="choice1">Choice B</option>
            <option value="choice2">Choice C</option>
            <option value="choice3">Choice D</option>
          </select>
          <button type="button" class="primary" id="btnInsertTableLatex">Insert LaTeX</button>
        </div>
      </div>

      <div class="small muted" style="margin-bottom:10px;">
        Click into any cell to type. Add/remove by using Add Row/Column. (Row labels remain A., B., C., … automatically.)
      </div>

      <div id="tableBuilderHost" class="tb-host"></div>

      <div class="small muted" style="margin-top:10px;">
        Tip: If you insert into the prompt, set the four choices to just “A”, “B”, “C”, “D” (or leave blank text).
      </div>
    </div>
  </div>
</div>




<!-- Graph Builder Modal -->
<div id="graphModal" class="tb-modal" style="display:none;">
  <div class="tb-modal-card graph-card">
    <div class="tb-modal-hd">
      <div style="font-weight:600;">Graph Builder (Interactive)</div>
      <button type="button" id="btnCloseGraphModal">Close</button>
    </div>

    <div class="tb-modal-bd graph-bd">
      <div class="graph-left">
        <div class="graph-toolbar">
          <div class="btnrow" style="margin-top:10px;">
          <button type="button" class="gbtn" id="btnToolPoint">Point</button>
          <button type="button" class="gbtn" id="btnToolLine">Line</button>
          <button type="button" class="gbtn" id="btnToggleGrid">Grid</button>
        </div>


          <div class="graph-ctrl">
            <div class="small muted" style="margin-bottom:6px;">Grid size (a)</div>
            <div class="graph-arrows">
              <button type="button" class="gbtn" id="gUp">▲</button>
              <div class="graph-arrows-mid">
                <button type="button" class="gbtn" id="gLeft">◀</button>
                <button type="button" class="gbtn" id="gDown">▼</button>
                <button type="button" class="gbtn" id="gRight">▶</button>
              </div>
              <div class="graph-arrows-row">
                <button type="button" class="gbtn" id="gMinus">–</button>
                <div class="greadout" id="gAReadout">a = 7</div>
                <button type="button" class="gbtn" id="gPlus">+</button>
              </div>
            </div>
            <div class="small muted" style="margin-top:6px;">
              +/– changes grid size. Arrows pan view (optional; you can ignore pan if you want).
            </div>
          </div>

          <div class="graph-ctrl">
            <div class="small muted" style="margin-bottom:6px;">Insert into</div>
            <select id="graphInsertTarget">
              <option value="prompt">Question Prompt</option>
              <option value="choice0">Choice A (MC only)</option>
              <option value="choice1">Choice B (MC only)</option>
              <option value="choice2">Choice C (MC only)</option>
              <option value="choice3">Choice D (MC only)</option>
            </select>

            <div class="grid2" style="margin-top:10px;">
              <div class="field" style="margin:0;">
                <label>Scale</label>
                <input type="number" id="gScale" value="0.45" step="0.05" min="0.05">
              </div>
              <div class="field" style="margin:0;">
                <label>Axis padding</label>
                <input type="number" id="gPad" value="0.5" step="0.1" min="0">
              </div>
            </div>

            <div class="grid2">
              <div class="field" style="margin:0;">
                <label>Domain min</label>
                <input type="number" id="gDomMin" value="-2.6" step="0.1">
              </div>
              <div class="field" style="margin:0;">
                <label>Domain max</label>
                <input type="number" id="gDomMax" value="2.6" step="0.1">
              </div>
            </div>

            <div class="field" style="margin:0;">
              <label>Samples</label>
              <input type="number" id="gSamples" value="200" step="10" min="20">
            </div>
          </div>
        </div>

        <div class="graph-stage">
          <!-- Interactive SVG grid -->
          <svg id="graphSvg" viewBox="0 0 600 600" class="graph-svg" aria-label="Graph editor"></svg>
          <div class="graph-hint small muted">
            Click a square intersection to place a point. Click a point to edit label. Drag to move.
          </div>
        </div>
      </div>

    <div class="graph-right">
  <!-- Plots -->
  <div class="panel" style="box-shadow:none;">
    <div class="hd">
      <div class="title">Plots (multiple functions)</div>
      <button type="button" class="primary" id="btnAddPlot">+ Add plot</button>
    </div>
    <div class="bd" id="plotsHost"></div>
  </div>

  <!-- Lines (NOW ONLY IN GRAPH BUILDER) -->
  <div class="panel" style="box-shadow:none; margin-top:12px;">
    <div class="hd">
      <div class="title">Lines</div>
      <div class="btnrow" style="gap:8px;">
        <button type="button" id="btnUndoLine">Undo</button>
        <button type="button" class="danger" id="btnClearLines">Clear</button>
        <button type="button" class="danger" id="btnDeleteLine" disabled>Delete Selected</button>
      </div>
    </div>
    <div class="bd">
      <div id="linesHost" class="lines-host"></div>
      <div class="small muted" style="margin-top:8px;">
        Tip: click a line in the graph to select it, then Delete Selected.
      </div>
    </div>
  </div>

  <!-- Points -->
  <div class="panel" style="box-shadow:none; margin-top:12px;">
    <div class="hd">
      <div class="title">Points</div>
      <button type="button" id="btnClearPoints">Clear</button>
    </div>
    <div class="bd">
      <div id="pointEditor" class="point-editor" style="display:none;">
        <div class="small muted" style="margin-bottom:8px;">Selected point</div>
        <div class="grid2">
          <div class="field" style="margin:0;">
            <label>x</label>
            <input type="number" id="pX" step="1">
          </div>
          <div class="field" style="margin:0;">
            <label>y</label>
            <input type="number" id="pY" step="1">
          </div>
        </div>

        <div class="field" style="margin-top:8px;">
          <label>Label (LaTeX)</label>
          <input type="text" id="pLabel" placeholder="e.g., A or (2,3)">
        </div>

        <div class="field">
          <label>Label position</label>
          <select id="pPos">
            <option value="above" selected>above</option>
            <option value="below">below</option>
            <option value="left">left</option>
            <option value="right">right</option>
            <option value="above right">above right</option>
            <option value="below right">below right</option>
            <option value="above left">above left</option>
            <option value="below left">below left</option>
          </select>
        </div>

        <div class="btnrow">
          <button type="button" class="danger" id="btnDeletePoint">Delete point</button>
        </div>
      </div>

      <div class="hr"></div>

      <div id="pointsHost" class="points-host"></div>

      <div class="btnrow" style="justify-content:flex-end; margin-top:10px;">
        <button type="button" class="primary" id="btnInsertGraphLatex">Insert LaTeX</button>
      </div>
    </div>
  </div>
</div>
  

    </div>
  </div>
</div>





<script>
(() => {
  const state = {
  questions: [],
  selectedId: null,
  savedKeys: [] // array of snapshots
  };


  const el = (id) => document.getElementById(id);

  function showHome() {
  el("homeScreen").style.display = "block";
  el("builderScreen").style.display = "none";
}

function showBuilder() {
  el("homeScreen").style.display = "none";
  el("builderScreen").style.display = "block";
}


  function uid(prefix="q") {
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function escapeLatexUnsafe(str) {
    return str ?? "";
  }

  function clamp4Choices(q) {
    if (!q.choices || q.choices.length !== 4) {
      q.choices = [
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" }
      ];
    }
    if (!q.correctChoiceId) q.correctChoiceId = q.choices[0].id;
  }

  function renderQuestionCard(q, idx, parent) {
    const card = document.createElement("div");
    card.className = "qcard" + (q.id === state.selectedId ? " active" : "");
    card.dataset.id = q.id;

    const handle = document.createElement("div");
    handle.className = "handle";
    handle.textContent = "≡";

    const meta = document.createElement("div");
    meta.className = "qmeta";

    const top = document.createElement("div");
    top.className = "topline";

    const badge = document.createElement("span");
    badge.className = "badge";
    badge.textContent = q.type.replace("_"," ").toUpperCase();

    const idxSpan = document.createElement("span");
    idxSpan.className = "badge";
    if (q.type === "info") {
      idxSpan.textContent = "INFO";
    } else {
      idxSpan.textContent = "Q" + questionNumberUpTo(idx);
    }

    top.appendChild(badge);
    top.appendChild(idxSpan);

    const prev = document.createElement("div");
    prev.className = "qpreview";
    const previewText = (q.prompt || "").replace(/\s+/g," ").trim();
    prev.textContent = previewText
      ? previewText.slice(0,70) + (previewText.length > 70 ? "…" : "")
      : "(no prompt yet)";

    const actions = document.createElement("div");
    actions.className = "qactions";

    const lbl = document.createElement("label");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!q.selected;
    cb.addEventListener("change", e => q.selected = e.target.checked);

    lbl.appendChild(cb);
    lbl.appendChild(document.createTextNode("Selected"));
    actions.appendChild(lbl);

    meta.appendChild(top);
    meta.appendChild(prev);
    meta.appendChild(actions);

    card.appendChild(handle);
    card.appendChild(meta);

    card.addEventListener("click", e => {
      if (e.target.tagName === "INPUT") return;
      state.selectedId = q.id;
      renderList();
      loadEditor(q.id);
    });

    parent.appendChild(card);
  }



  function questionNumberUpTo(index) {
  let n = 0;
  for (let k = 0; k <= index; k++) {
    if (state.questions[k].type !== "info") n++;
  }
  return n;
  }

  function getDisplayedLabelAtIndex(index) {
    const q = state.questions[index];
    if (!q) return "";
    if (q.type === "info") return "INFO";
    return "Q" + questionNumberUpTo(index);
  }


  function renderList() {
    const list = el("qList");
    list.innerHTML = "";

    let i = 0;

    while (i < state.questions.length) {
      const q = state.questions[i];

      // Not grouped: render directly
      if (!q.groupId) {
        renderQuestionCard(q, i, list);
        i++;
        continue;
      }

      // Grouped: wrap contiguous items in qgroup container
      const gid = q.groupId;
      const groupDiv = document.createElement("div");
      groupDiv.className = "qgroup";
      groupDiv.dataset.gid = gid;

      // Group handle so the whole block is draggable
      const gHandle = document.createElement("div");
      gHandle.className = "handle groupHandle";
      gHandle.textContent = "≡ GROUP";
      groupDiv.appendChild(gHandle);


      let j = i;
      while (j < state.questions.length && state.questions[j].groupId === gid) {
        renderQuestionCard(state.questions[j], j, groupDiv);
        j++;
      }

      list.appendChild(groupDiv);
      i = j;
    }

    el("qCount").textContent = state.questions.length.toString();
  }


  function loadEditor(qid) {
    const q = state.questions.find(x => x.id === qid);
    if (!q) {
      el("selectedInfo").textContent = "No question selected.";
      el("editorArea").style.display = "none";
      return;
    }
    const idx = state.questions.indexOf(q);
    el("selectedInfo").textContent =
      `Editing ${qid} (rendered position: ${q.type === "info" ? "INFO" : ("Q" + questionNumberUpTo(idx))})`;
    el("editorArea").style.display = "block";

    el("qType").value = q.type;
    el("qPoints").value = (q.points ?? "") === null ? "" : (q.points ?? "");
    el("qPrompt").value = q.prompt ?? "";
    el("qImages").value = (q.images ?? []).join("\n");

        // Hide points for Info items (not a question)
    if (q.type === "info") {
      el("qPoints").value = "";
      el("qPoints").disabled = true;
    } else {
      el("qPoints").disabled = false;
    }

    if (q.type === "multiple_choice") {
      el("mcArea").style.display = "block";
      el("mcColumnsField").style.display = "block";

      clamp4Choices(q);
      renderMCChoices(q);

      el("mcColumns").value = q.mcColumns || 1;
    } else {
      el("mcArea").style.display = "none";
      el("mcColumnsField").style.display = "none";
    }



    // Numeric-only editor area
    if (q.type === "numeric") {
      el("numericArea").style.display = "block";
      el("numAnswer").value = q.numericAnswer || "";
    } else {
      el("numericArea").style.display = "none";
    }


  }

  function renderMCChoices(q) {
    const box = el("mcChoices");
    box.innerHTML = "";
    const letters = ["A", "B", "C", "D"];

    q.choices.forEach((ch, i) => {
      const row = document.createElement("div");
      row.className = "choiceRow";

      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "correctChoice";
      radio.checked = (q.correctChoiceId === ch.id);
      radio.addEventListener("change", () => { q.correctChoiceId = ch.id; });

      const inp = document.createElement("input");
      inp.type = "text";
      inp.placeholder = `${letters[i]} choice text`;
      inp.value = ch.text ?? "";
      inp.addEventListener("input", (e) => { ch.text = e.target.value; });

      row.appendChild(radio);
      row.appendChild(inp);
      box.appendChild(row);
    });
  }

  function createQuestion(type) {
  const base = {
    id: uid("q"),
    type,
    // Default points: MC + Numeric => 1, others blank
    points: (type === "multiple_choice" || type === "numeric") ? 1 : "",
    prompt: "",
    images: [],
    shuffleSelected: true,
    choices: null,
    correctChoiceId: null,
    numericAnswer: "",
    infoImageScale: "0.75",
    mcColumns: 1
  };

  if (type === "multiple_choice") {
    base.choices = [
      { id: uid("c"), text: "" },
      { id: uid("c"), text: "" },
      { id: uid("c"), text: "" },
      { id: uid("c"), text: "" }
    ];
    base.correctChoiceId = base.choices[0].id;
  }

  state.questions.push(base);
  state.selectedId = base.id;
  renderList();
  loadEditor(base.id);
}


  function saveEdits() {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q) return;

    q.type = el("qType").value;
    q.points = el("qPoints").value === "" ? "" : Number(el("qPoints").value);
    q.prompt = el("qPrompt").value;

    const imgs = el("qImages").value.split("\n").map(s => s.trim()).filter(Boolean);
    q.images = imgs;

    if (q.type === "numeric") {
      q.numericAnswer = el("numAnswer").value || "";
    }

    if (q.type === "multiple_choice") {
      clamp4Choices(q);
      const v = Number(el("mcColumns").value);
      q.mcColumns = (v === 2 || v === 4) ? v : 1;
    }



    renderList();
    loadEditor(q.id);
    saveToCache();

  }

  function deleteSelected() {
    const idx = state.questions.findIndex(x => x.id === state.selectedId);
    if (idx < 0) return;
    state.questions.splice(idx, 1);
    state.selectedId = state.questions[idx]?.id || state.questions[idx - 1]?.id || null;
    renderList();
    loadEditor(state.selectedId);
  }

  function duplicateSelected() {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q) return;

    const copy = JSON.parse(JSON.stringify(q));
    copy.id = uid("q");
    copy.shuffleSelected = true;

    if (copy.type === "multiple_choice") {
      const oldToNew = new Map();
      copy.choices.forEach(ch => {
        const oldId = ch.id;
        ch.id = uid("c");
        oldToNew.set(oldId, ch.id);
      });
      copy.correctChoiceId = oldToNew.get(copy.correctChoiceId) || copy.choices[0].id;
    }

    const idx = state.questions.findIndex(x => x.id === state.selectedId);
    state.questions.splice(idx + 1, 0, copy);
    state.selectedId = copy.id;
    renderList();
    loadEditor(copy.id);
  }

  function shuffleSelected() {
    const units = getGroupUnits(state.questions);

    const selectedUnitIndexes = [];
    const selectedUnits = [];

    units.forEach((u, idx) => {
      const isSelectedUnit = u.items.some(q => q.selected);
      if (isSelectedUnit) {
        selectedUnitIndexes.push(idx);
        selectedUnits.push(u);
      }
    });

    if (selectedUnits.length < 2) return;

    if (selectedUnits.length === 2) {
      [selectedUnits[0], selectedUnits[1]] = [selectedUnits[1], selectedUnits[0]];
    } else {
      const originalSig = selectedUnits.map(u => u.ids.join("|")).join("||");
      for (let attempt = 0; attempt < 12; attempt++) {
        shuffleArrayInPlace(selectedUnits);
        const newSig = selectedUnits.map(u => u.ids.join("|")).join("||");
        if (newSig !== originalSig) break;
      }
    }

    selectedUnitIndexes.forEach((unitPos, k) => {
      units[unitPos] = selectedUnits[k];
    });

    state.questions = units.flatMap(u => u.items);

    // Keep selections: do NOT clear q.selected
    renderList();
    loadEditor(state.selectedId);

    refreshAfterReorder();
  }


function sameOrderByUnit(unitsA, unitsB) {
  if (unitsA.length !== unitsB.length) return false;
  for (let i = 0; i < unitsA.length; i++) {
    // Compare by a stable signature; ids list is stable for the unit
    const a = unitsA[i].ids.join("|");
    const b = unitsB[i].ids.join("|");
    if (a !== b) return false;
  }
  return true;
}

function forceDifferentShuffleUnits(units) {
  if (units.length < 2) return false;

  // Make a copy to compare against
  const original = units.map(u => ({ ids: [...u.ids], items: u.items }));

  // If exactly 2, just swap for guaranteed change
  if (units.length === 2) {
    [units[0], units[1]] = [units[1], units[0]];
    return true;
  }

  // Try a few times to get a different permutation
  for (let attempt = 0; attempt < 12; attempt++) {
    shuffleArrayInPlace(units);
    if (!sameOrderByUnit(units, original)) return true;
  }

  // Extremely unlikely fallback: force a change by swapping first two
  [units[0], units[1]] = [units[1], units[0]];
  return true;
}

  function shuffleAll() {
  const units = getGroupUnits(state.questions);

  const changed = forceDifferentShuffleUnits(units);
  if (!changed) return;

  state.questions = units.flatMap(u => u.items);

  renderList();
  loadEditor(state.selectedId);

  refreshAfterReorder();
}


function shuffleWithinGroups({ onlySelectedGroups = false } = {}) {
  const units = getGroupUnits(state.questions);

  units.forEach(u => {
    const isGrouped = u.items.length > 1 && u.items[0].groupId;
    if (!isGrouped) return;

    if (onlySelectedGroups) {
      const selectedInUnit = u.items.some(q => q.selected);
      if (!selectedInUnit) return;
    }

    if (u.items.length === 2) {
      [u.items[0], u.items[1]] = [u.items[1], u.items[0]];
    } else if (u.items.length > 2) {
      const originalSig = u.items.map(x => x.id).join("|");
      for (let attempt = 0; attempt < 12; attempt++) {
        shuffleArrayInPlace(u.items);
        const newSig = u.items.map(x => x.id).join("|");
        if (newSig !== originalSig) break;
      }
    }
  });

  state.questions = units.flatMap(u => u.items);

  renderList();
  loadEditor(state.selectedId);

  refreshAfterReorder();
}



function getGroupUnits(list) {
  // Returns units: each unit is { ids: [...], items: [...] }
  // A unit is either one ungrouped question, or a contiguous group (same groupId).
  const units = [];
  let i = 0;

  while (i < list.length) {
    const q = list[i];
    if (!q.groupId) {
      units.push({ ids: [q.id], items: [q] });
      i++;
      continue;
    }

    // collect contiguous items with same groupId
    const gid = q.groupId;
    const items = [];
    const ids = [];
    let j = i;
    while (j < list.length && list[j].groupId === gid) {
      items.push(list[j]);
      ids.push(list[j].id);
      j++;
    }
    units.push({ ids, items });
    i = j;
  }

  return units;
}

function groupSelected() {
  const selected = state.questions.filter(q => q.selected);
  if (selected.length < 2) return;

  // Keep relative order as currently shown
  const selectedIds = new Set(selected.map(q => q.id));

  // Find earliest index among selected questions
  const firstIndex = state.questions.findIndex(q => selectedIds.has(q.id));

  // Remove selected from list
  const remaining = state.questions.filter(q => !selectedIds.has(q.id));

  // Insert them back contiguously at firstIndex
  remaining.splice(firstIndex, 0, ...selected);

  // Assign groupId (same for all in selection)
  const gid = uid("g");
  selected.forEach(q => { q.groupId = gid; });

  // Replace list
  state.questions = remaining;

  // Optional: uncheck after grouping (recommended)
  selected.forEach(q => { q.selected = false; });

  renderList();
  loadEditor(state.selectedId);
}

function ungroupSelected() {
  // Find any selected question that has a groupId
  const picked = state.questions.find(q => q.selected && q.groupId);
  if (!picked) return;

  const gid = picked.groupId;

  // Remove groupId from all questions in that group
  state.questions.forEach(q => {
    if (q.groupId === gid) q.groupId = null;
  });

  // Optional: clear selection
  state.questions.forEach(q => { q.selected = false; });

  renderList();
  loadEditor(state.selectedId);
}

function removeTableColumn() {
  // Keep at least 1 column
  if (tableBuilder.cols.length <= 1) return;

  tableBuilder.cols.pop();
  tableBuilder.cells.forEach(row => row.pop());
  renderTableBuilder();
}

function removeTableRow() {
  // Keep at least 1 row
  if (tableBuilder.rows.length <= 1) return;

  tableBuilder.rows.pop();
  tableBuilder.cells.pop();
  renderTableBuilder();
}


function shuffleArrayInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function groupNumberMap() {
  const map = new Map();
  let n = 1;
  state.questions.forEach(q => {
    if (q.groupId && !map.has(q.groupId)) map.set(q.groupId, n++);
  });
  return map;
}

function getAnswerLabel(q) {
  if (q.type === "multiple_choice") {
    clamp4Choices(q);
    const idx = q.choices.findIndex(c => c.id === q.correctChoiceId);
    return ["A","B","C","D"][Math.max(0, idx)];
  }
  if (q.type === "numeric") {
    return (q.numericAnswer && q.numericAnswer.trim()) ? q.numericAnswer.trim() : "(no answer)";
  }
  return "(written)";
}

function saveKeySnapshot() {
  if (!state.questions.length) return;

  const name = prompt("Name this key snapshot (e.g., Version A) :", `Key ${state.savedKeys.length + 1}`);
  if (name === null) return;

  const snapshot = {
    id: uid("key"),
    name: (name || `Key ${state.savedKeys.length + 1}`).trim(),
    createdAt: new Date().toISOString(),
    order: state.questions.map(q => q.id),
    info: state.questions.map((q, idx) => ({
    qid: q.id,
    originalIndex: idx,                 // keep raw position for internal tracking
    originalLabel: getDisplayedLabelAtIndex(idx),  // Q# or INFO
    type: q.type,
    groupId: q.groupId || null,
    answer: (q.type === "info") ? "—" : getAnswerLabel(q),
    promptPreview: (q.prompt || "").replace(/\s+/g, " ").trim().slice(0, 60)
  }))

  };

  state.savedKeys.unshift(snapshot);
  renderShuffleMap(snapshot.id);
}

function latestSnapshotId() {
  return state.savedKeys.length ? state.savedKeys[0].id : null;
}

function renderShuffleMap(snapshotId = null) {
  const out = el("shuffleMapOut");
  if (!state.savedKeys.length) {
    out.innerHTML = `<div class="small muted">No saved key snapshots yet.</div>`;
    return;
  }

  const snap = snapshotId
    ? state.savedKeys.find(s => s.id === snapshotId)
    : state.savedKeys[0];

  if (!snap) {
    out.innerHTML = `<div class="small muted">Snapshot not found.</div>`;
    return;
  }




  // Build current index lookup: qid -> current index (0-based)
  const currentIndex = new Map();
  state.questions.forEach((q, idx) => currentIndex.set(q.id, idx));

  // Build group numbering map (nice display)
  const gmap = groupNumberMap();

  const rows = snap.info.map(item => {
    const nowIdx = currentIndex.get(item.qid);
    const isMissing = (nowIdx === undefined);

    const nowLabel = isMissing ? "(deleted)" : getDisplayedLabelAtIndex(nowIdx);

    // moved: label changed (Q# changes) — this ignores INFO counting as a question
    const moved = !isMissing && nowLabel !== item.originalLabel;

    const groupLabel = item.groupId ? `GROUP ${gmap.get(item.groupId) || "?"}` : "";

    return `<tr>
      <td>${item.originalLabel}</td>
      <td>${isMissing ? `<span class="muted">(deleted)</span>` : nowLabel}</td>
      <td>${item.type.replace("_"," ")}</td>
      <td>${groupLabel}</td>
      <td>${item.answer}</td>
      <td>${item.promptPreview}${(item.promptPreview || "").length >= 60 ? "…" : ""}</td>
      <td>${isMissing ? "—" : (moved ? "Moved" : "Same")}</td>
    </tr>`;
  }).join("");

  out.innerHTML = `
    <div class="small muted" style="margin-bottom:8px;">
      Snapshot: <b>${snap.name}</b> • Saved: ${new Date(snap.createdAt).toLocaleString()}
    </div>
    <table>
      <thead>
        <tr>
          <th>Original #</th>
          <th>Current #</th>
          <th>Type</th>
          <th>Group</th>
          <th>Answer</th>
          <th>Prompt (preview)</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}



// ----------------------
// LocalStorage persistence
// ----------------------
const STORAGE_KEY = "exam_builder_state_v1";

function saveToCache() {
  try {
    const payload = {
      version: 1,
      savedAt: new Date().toISOString(),
      state: {
        questions: state.questions,
        selectedId: state.selectedId
      },
      meta: {
        testName: el("testName")?.value ?? "",
        gradeSubject: el("gradeSubject")?.value ?? "",
        headerImage: el("headerImage")?.value ?? "",
        instructions: el("instructions")?.value ?? ""
      }
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  } catch (e) {
    console.error("Failed to save to cache:", e);
  }
}

function loadFromCache() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;

    const payload = JSON.parse(raw);
    if (!payload || !payload.state) return false;

    // Restore state
    state.questions = payload.state.questions || [];
    state.selectedId = payload.state.selectedId || null;

    // Restore form fields
    if (payload.meta) {
      if (el("testName")) el("testName").value = payload.meta.testName || "";
      if (el("gradeSubject")) el("gradeSubject").value = payload.meta.gradeSubject || "";
      if (el("headerImage")) el("headerImage").value = payload.meta.headerImage || "";
      if (el("instructions")) el("instructions").value = payload.meta.instructions || "";
    }

    return true;
  } catch (e) {
    console.error("Failed to load from cache:", e);
    return false;
  }
}

function clearCache() {
  localStorage.removeItem(STORAGE_KEY);
}





// ----------------------
// Table Builder (MC matrix)
// ----------------------
const tableBuilder = {
  cols: ["Column 1", "Column 2", "Column 3", "Column 4"],
  rows: ["A.", "B.", "C.", "D."],
  // cells[r][c] is the cell text for row r, column c
  cells: [
    ["", "", "", ""],
    ["", "", "", ""],
    ["", "", "", ""],
    ["", "", "", ""]
  ]
};

function openTableModal() {
  el("tableModal").style.display = "block";
  renderTableBuilder();
}

function closeTableModal() {
  el("tableModal").style.display = "none";
}

function ensureTableDimensions() {
  // Ensure each row has correct column count
  tableBuilder.cells.forEach((row, r) => {
    while (row.length < tableBuilder.cols.length) row.push("");
    if (row.length > tableBuilder.cols.length) row.length = tableBuilder.cols.length;
  });
}

function addTableColumn() {
  tableBuilder.cols.push(`Column ${tableBuilder.cols.length + 1}`);
  tableBuilder.cells.forEach(row => row.push(""));
  renderTableBuilder();
}

function addTableRow() {
  const nextLetter = String.fromCharCode("A".charCodeAt(0) + tableBuilder.rows.length);
  tableBuilder.rows.push(`${nextLetter}.`);
  tableBuilder.cells.push(Array(tableBuilder.cols.length).fill(""));
  renderTableBuilder();
}

function renderTableBuilder() {
  ensureTableDimensions();

  const host = el("tableBuilderHost");
  const table = document.createElement("table");
  table.className = "tb-grid";
  table.style.width = "100%";
  table.style.borderCollapse = "collapse";

  // Header row
  const thead = document.createElement("thead");
  const hr = document.createElement("tr");

  const corner = document.createElement("th");
  corner.textContent = "";
  corner.style.border = "1px solid #24324a";
  corner.style.padding = "6px 8px";
  hr.appendChild(corner);

  tableBuilder.cols.forEach((h, c) => {
    const th = document.createElement("th");
    th.style.border = "1px solid #24324a";
    th.style.padding = "6px 8px";

    const inp = document.createElement("input");
    inp.type = "text";
    inp.value = h;
    inp.addEventListener("input", (e) => {
      tableBuilder.cols[c] = e.target.value;
    });
    th.appendChild(inp);
    hr.appendChild(th);
  });

  thead.appendChild(hr);
  table.appendChild(thead);

  // Body rows
  const tbody = document.createElement("tbody");
  tableBuilder.rows.forEach((label, r) => {
    const tr = document.createElement("tr");

    const rowLabel = document.createElement("td");
    rowLabel.style.border = "1px solid #24324a";
    rowLabel.style.padding = "6px 8px";
    rowLabel.style.whiteSpace = "nowrap";

    const inpLabel = document.createElement("input");
    inpLabel.type = "text";
    inpLabel.value = label;
    inpLabel.addEventListener("input", (e) => {
      tableBuilder.rows[r] = e.target.value;
    });

    rowLabel.appendChild(inpLabel);
    tr.appendChild(rowLabel);

    tableBuilder.cols.forEach((_, c) => {
      const td = document.createElement("td");
      td.style.border = "1px solid #24324a";
      td.style.padding = "6px 8px";

      const inp = document.createElement("input");
      inp.type = "text";
      inp.value = tableBuilder.cells[r][c] ?? "";
      inp.addEventListener("input", (e) => {
        tableBuilder.cells[r][c] = e.target.value;
      });

      td.appendChild(inp);
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);

  host.innerHTML = "";
  host.appendChild(table);
}

function latexEscapeCell(s) {
  // Minimal escaping so tabular doesn't break. Teachers can still type LaTeX if needed.
  // Key: escape & which would split columns.
  return (s ?? "").replaceAll("&", "\\&");
}

function buildLatexTable() {
  ensureTableDimensions();

  // Column spec: first column is left-aligned, others centered
  const colSpec = "|l|" + tableBuilder.cols.map(() => "c|").join("");

  const header = ` & ${tableBuilder.cols.map(latexEscapeCell).join(" & ")} \\\\ \\hline`;

  const rows = tableBuilder.rows.map((lab, r) => {
    const cells = tableBuilder.cells[r].map(latexEscapeCell).join(" & ");
    return `${latexEscapeCell(lab)} & ${cells} \\\\ \\hline`;
  }).join("\n");

  return [
    "\\begin{center}",
    "\\renewcommand{\\arraystretch}{1.3}",
    `\\begin{tabular}{${colSpec}}`,
    "\\hline",
    header,
    rows,
    "\\end{tabular}",
    "\\end{center}"
  ].join("\n");
}

function latexBlockHeader(q) {
  // sentinel comment for robust importing + needspace for page-breaking control
  return [
    `%==QBLOCK id=${q.id}==`,
    `\\Needspace{12\\baselineskip}`
  ].join("\n");
}

function insertTableLatex() {
  const target = el("tableInsertTarget").value;
  const latex = buildLatexTable();

  const q = state.questions.find(x => x.id === state.selectedId);
  if (!q) return;

  if (target === "prompt") {
    const ta = el("qPrompt");
    const start = ta.selectionStart ?? ta.value.length;
    const end = ta.selectionEnd ?? ta.value.length;
    ta.value = ta.value.slice(0, start) + "\n" + latex + "\n" + ta.value.slice(end);
    q.prompt = ta.value;
    return;
  }

  if (q.type !== "multiple_choice") return;
  clamp4Choices(q);

  const idx = Number(target.replace("choice", ""));
  if (Number.isNaN(idx) || idx < 0 || idx > 3) return;

  q.choices[idx].text = (q.choices[idx].text || "") + "\n" + latex;

  loadEditor(q.id);
}

// ----------------------
// Graph Builder (Interactive SVG + Multi-Plot)
// ----------------------

const graphBuilder = {
  // view settings
  a: 7,
  pad: 0.5,
  scale: 0.45,
  domMin: -2.6,
  domMax: 2.6,
  samples: 200,
  
  // optional panning (integer offset in grid units)
  panX: 0,
  panY: 0,

  showGrid: true,
  showAxes: true,
  lines: [],
  selectedLineId: null,

  tool: { mode: "point", lineStart: null },  // point/line tool state

  // multi-plot functions
  plots: [
    { id: uid("plot"), expr: "x^2", style: "thin" }
  ],

  // points
  points: [], // { id, x, y, label, pos }
  selectedPointId: null,

  // svg cached
  svgSize: 600
};

function openGraphModal() {
  el("graphModal").style.display = "block";
  el("gScale").value = graphBuilder.scale;
  el("gPad").value = graphBuilder.pad;
  el("gDomMin").value = graphBuilder.domMin;
  el("gDomMax").value = graphBuilder.domMax;
  el("gSamples").value = graphBuilder.samples;

  renderPlotsUI();
  renderPointsUI();
  renderLinesUI();   // <— add this
  drawGraphSvg();
  updateAReadout();
}


function closeGraphModal() {
  el("graphModal").style.display = "none";
}

function updateAReadout() {
  el("gAReadout").textContent = `a = ${graphBuilder.a}`;
}

function clampA(n) {
  return Math.max(1, Math.min(30, n)); // safety
}

function graphWorldBounds() {
  // world coords visible
  const a = graphBuilder.a;
  return {
    xmin: -a + graphBuilder.panX,
    xmax:  a + graphBuilder.panX,
    ymin: -a + graphBuilder.panY,
    ymax:  a + graphBuilder.panY
  };
}

function worldToSvg(x, y) {
  const { xmin, xmax, ymin, ymax } = graphWorldBounds();
  const S = graphBuilder.svgSize;

  const px = (x - xmin) / (xmax - xmin) * S;
  const py = (ymax - y) / (ymax - ymin) * S; // invert y
  return { px, py };
}

function svgToWorld(px, py) {
  const { xmin, xmax, ymin, ymax } = graphWorldBounds();
  const S = graphBuilder.svgSize;

  const x = xmin + (px / S) * (xmax - xmin);
  const y = ymax - (py / S) * (ymax - ymin);
  return { x, y };
}

function snap(n) {
  return Math.round(n); // snap to integer grid intersections
}

function svgEl(name, attrs = {}) {
  const n = document.createElementNS("http://www.w3.org/2000/svg", name);
  Object.entries(attrs).forEach(([k, v]) => n.setAttribute(k, String(v)));
  return n;
}

// --- Helpers required by drawGraphSvg() ---

function safeEvalExpr(expr, x) {
  // Supports: numbers, x, + - * / ^, parentheses, decimals, spaces
  // Converts ^ to JS **. Returns NaN on invalid input.
  const s = String(expr || "").trim();
  if (!s) return NaN;

  // Very small sanitization to avoid arbitrary JS:
  // allow digits, x/X, operators, parentheses, decimal point, spaces
  if (!/^[0-9xX+\-*/^().\s]+$/.test(s)) return NaN;

  const js = s.replace(/\bX\b/g, "x").replace(/\^/g, "**");

  try {
    // eslint-disable-next-line no-new-func
    const fn = new Function("x", `return (${js});`);
    const y = fn(x);
    return Number.isFinite(y) ? y : NaN;
  } catch {
    return NaN;
  }
}

function plotToPath(expr, samples = 500) {
  const { xmin, xmax, ymin, ymax } = graphWorldBounds();

  const dx = (xmax - xmin) / samples;
  let d = "";
  let penDown = false;

  for (let i = 0; i <= samples; i++) {
    const x = xmin + i * dx;
    const y = safeEvalExpr(expr, x);

    if (!Number.isFinite(y)) {
      penDown = false;
      continue;
    }

    // Simple clipping: if far off-screen, lift pen
    if (y < ymin - 5 || y > ymax + 5) {
      penDown = false;
      continue;
    }

    const { px, py } = worldToSvg(x, y);

    if (!penDown) {
      d += `M ${px.toFixed(2)} ${py.toFixed(2)} `;
      penDown = true;
    } else {
      d += `L ${px.toFixed(2)} ${py.toFixed(2)} `;
    }
  }

  return d.trim();
}


// --- REPLACE YOUR EXISTING drawGraphSvg() WITH THIS ---
function drawGraphSvg() {
  const svg = el("graphSvg");
  svg.innerHTML = "";

  const S = graphBuilder.svgSize;
  const { xmin, xmax, ymin, ymax } = graphWorldBounds();

  // Background
  svg.appendChild(svgEl("rect", { x: 0, y: 0, width: S, height: S, fill: "#ffffff" }));

  // Grid
  if (graphBuilder.showGrid !== false) {
    for (let x = Math.ceil(xmin); x <= Math.floor(xmax); x++) {
      const { px } = worldToSvg(x, 0);
      svg.appendChild(svgEl("line", {
        x1: px, y1: 0, x2: px, y2: S,
        stroke: "rgba(17,24,39,0.08)"
      }));
    }
    for (let y = Math.ceil(ymin); y <= Math.floor(ymax); y++) {
      const { py } = worldToSvg(0, y);
      svg.appendChild(svgEl("line", {
        x1: 0, y1: py, x2: S, y2: py,
        stroke: "rgba(17,24,39,0.08)"
      }));
    }
  }

  // Axes
  if (graphBuilder.showAxes !== false) {
    if (xmin <= 0 && xmax >= 0) {
      const { px } = worldToSvg(0, 0);
      svg.appendChild(svgEl("line", {
        x1: px, y1: 0, x2: px, y2: S,
        stroke: "rgba(17,24,39,0.35)",
        "stroke-width": 2
      }));
    }
    if (ymin <= 0 && ymax >= 0) {
      const { py } = worldToSvg(0, 0);
      svg.appendChild(svgEl("line", {
        x1: 0, y1: py, x2: S, y2: py,
        stroke: "rgba(17,24,39,0.35)",
        "stroke-width": 2
      }));
    }
  }

  // Plots
  if (Array.isArray(graphBuilder.plots)) {
    graphBuilder.plots.forEach(pl => {
      const expr = (pl && pl.expr) ? String(pl.expr) : "";
      if (!expr.trim()) return;

      const d = plotToPath(expr, 650);
      if (!d) return;

      const style = (pl.style || "thin").trim();
      const strokeW = (style === "very thick") ? 3 : (style === "thick") ? 2 : 1.5;

      svg.appendChild(svgEl("path", {
        d,
        fill: "none",
        stroke: "rgba(17,24,39,0.75)",
        "stroke-width": strokeW,
        "stroke-linecap": "round",
        "stroke-linejoin": "round"
      }));
    });
  }

  // Lines (click-selectable)
  graphBuilder.lines = Array.isArray(graphBuilder.lines) ? graphBuilder.lines : [];
  graphBuilder.lines.forEach(L => {
    const a = worldToSvg(L.x1, L.y1);
    const b = worldToSvg(L.x2, L.y2);

    const isSel = (L.id === graphBuilder.selectedLineId);

    const lineEl = svgEl("line", {
      x1: a.px, y1: a.py, x2: b.px, y2: b.py,
      stroke: isSel ? "rgba(79,70,229,0.95)" : "rgba(79,70,229,0.65)",
      "stroke-width": isSel ? 4 : 2,
      "data-lid": L.id,
      "pointer-events": "stroke"
    });

    // easier clicking
    lineEl.style.cursor = "pointer";
    svg.appendChild(lineEl);
  });

  // Points
  graphBuilder.points = Array.isArray(graphBuilder.points) ? graphBuilder.points : [];
  graphBuilder.points.forEach(p => {
    const { px, py } = worldToSvg(p.x, p.y);
    const isSel = (p.id === graphBuilder.selectedPointId);

    const g = svgEl("g", { "data-pid": p.id });

    g.appendChild(svgEl("circle", {
      cx: px, cy: py, r: isSel ? 7 : 6,
      fill: isSel ? "rgba(79,70,229,0.40)" : "rgba(79,70,229,0.25)",
      stroke: "rgba(79,70,229,0.85)",
      "stroke-width": 2
    }));

    if (p.label) {
      const t = svgEl("text", {
        x: px + 10, y: py - 10,
        fill: "rgba(17,24,39,0.75)",
        "font-size": 12,
        "font-weight": 700
      });
      t.textContent = p.label;
      g.appendChild(t);
    }

    g.style.cursor = "pointer";
    svg.appendChild(g);
  });

  // Interactions
  svg.onmousedown = (evt) => {
    const targetPoint = evt.target.closest("g[data-pid]");
    if (targetPoint) {
      const pid = targetPoint.getAttribute("data-pid");
      graphBuilder.selectedLineId = null;
      selectPoint(pid);
      startDragPoint(evt, pid);
      renderLinesUI();
      return;
    }

    const targetLine = evt.target.closest("line[data-lid]");
    if (targetLine) {
      const lid = targetLine.getAttribute("data-lid");
      graphBuilder.selectedPointId = null;
      graphBuilder.selectedLineId = lid;
      el("pointEditor").style.display = "none";
      drawGraphSvg();
      renderLinesUI();
      return;
    }

    // Empty space -> add point or line endpoints
    const sp = clientToSvg(svg, evt.clientX, evt.clientY);
    const w = svgToWorld(sp.x, sp.y);
    const x = snap(w.x);
    const y = snap(w.y);

    graphBuilder.selectedLineId = null;

    if (graphBuilder.tool && graphBuilder.tool.mode === "line") {
      if (!graphBuilder.tool.lineStart) {
        graphBuilder.tool.lineStart = { x, y };
      } else {
        const s = graphBuilder.tool.lineStart;
        graphBuilder.lines.push({ id: uid("ln"), x1: s.x, y1: s.y, x2: x, y2: y });
        graphBuilder.tool.lineStart = null;
      }
      drawGraphSvg();
      renderLinesUI();
      return;
    }

    const pt = { id: uid("pt"), x, y, label: "", pos: "above right" };
    graphBuilder.points.push(pt);
    selectPoint(pt.id);
    renderPointsUI();
    renderLinesUI();
    drawGraphSvg();
  };

  svg.onmousemove = null;
  svg.onmouseup = null;
}





    

function startDragPoint(downEvt, pid) {
  const svg = el("graphSvg");

  function move(evt) {
    const sp = clientToSvg(svg, evt.clientX, evt.clientY); // svg-point
    const px = sp.x;
    const py = sp.y;

    const w = svgToWorld(px, py);
    const x = snap(w.x);
    const y = snap(w.y);

    const pt = graphBuilder.points.find(pp => pp.id === pid);
    if (!pt) return;

    pt.x = x;
    pt.y = y;

    // keep editor synced if selected
    if (graphBuilder.selectedPointId === pid) {
      el("pX").value = pt.x;
      el("pY").value = pt.y;
    }

    drawGraphSvg();
    renderPointsUI();
  }

  function up() {
    window.removeEventListener("mousemove", move);
    window.removeEventListener("mouseup", up);
  }

  window.addEventListener("mousemove", move);
  window.addEventListener("mouseup", up);
}


function selectPoint(pid) {
  graphBuilder.selectedPointId = pid;
  const p = graphBuilder.points.find(x => x.id === pid);
  const editor = el("pointEditor");
  if (!p) {
    editor.style.display = "none";
    return;
  }

  editor.style.display = "block";
  el("pX").value = p.x;
  el("pY").value = p.y;
  el("pLabel").value = p.label || "";
  el("pPos").value = p.pos || "above right";

  drawGraphSvg();
}

function renderLinesUI() {
  const host = el("linesHost");
  if (!host) return;

  host.innerHTML = "";

  const btnDel = el("btnDeleteLine");
  if (btnDel) btnDel.disabled = !graphBuilder.selectedLineId;

  if (!graphBuilder.lines || graphBuilder.lines.length === 0) {
    host.innerHTML = `<div class="small muted">No lines drawn.</div>`;
    return;
  }

  graphBuilder.lines.forEach((L, idx) => {
    const row = document.createElement("div");
    row.className = "line-row";
    row.style.display = "flex";
    row.style.justifyContent = "space-between";
    row.style.alignItems = "center";
    row.style.padding = "8px 10px";
    row.style.border = "1px solid rgba(36,50,74,0.18)";
    row.style.borderRadius = "10px";
    row.style.marginBottom = "8px";
    row.style.cursor = "pointer";
    row.style.background = (L.id === graphBuilder.selectedLineId) ? "rgba(79,70,229,0.06)" : "transparent";

    const left = document.createElement("div");
    left.innerHTML = `
      <div class="tag">Line ${idx + 1}</div>
      <div class="small muted">(${L.x1}, ${L.y1}) → (${L.x2}, ${L.y2})</div>
    `;

    const del = document.createElement("button");
    del.type = "button";
    del.textContent = "Delete";
    del.className = "danger";
    del.onclick = (e) => {
      e.stopPropagation();
      deleteLineById(L.id);
    };

    row.onclick = () => {
      graphBuilder.selectedPointId = null;
      graphBuilder.selectedLineId = L.id;
      el("pointEditor").style.display = "none";
      drawGraphSvg();
      renderLinesUI();
    };

    row.appendChild(left);
    row.appendChild(del);
    host.appendChild(row);
  });
}

function deleteLineById(lid) {
  graphBuilder.lines = (graphBuilder.lines || []).filter(x => x.id !== lid);
  if (graphBuilder.selectedLineId === lid) graphBuilder.selectedLineId = null;
  drawGraphSvg();
  renderLinesUI();
}

function undoLastLine() {
  if (!graphBuilder.lines || graphBuilder.lines.length === 0) return;
  const removed = graphBuilder.lines.pop();
  if (removed && graphBuilder.selectedLineId === removed.id) graphBuilder.selectedLineId = null;
  drawGraphSvg();
  renderLinesUI();
}

function clearAllLines() {
  graphBuilder.lines = [];
  graphBuilder.selectedLineId = null;
  graphBuilder.tool.lineStart = null;
  drawGraphSvg();
  renderLinesUI();
}



function renderPointsUI() {
  const host = el("pointsHost");
  host.innerHTML = "";

  graphBuilder.points.forEach(p => {
    const row = document.createElement("div");
    row.className = "point-row";
    row.style.cursor = "pointer";

    const left = document.createElement("div");
    left.innerHTML = `
      <div class="tag">(${p.x}, ${p.y})</div>
      <div class="small muted">${p.label ? `Label: ${p.label}` : "No label"}</div>
    `;

    const btn = document.createElement("button");
    btn.type = "button";
    btn.textContent = "Edit";
    btn.onclick = (e) => {
      e.stopPropagation();
      selectPoint(p.id);
    };

    row.appendChild(left);
    row.appendChild(btn);

    row.onclick = () => selectPoint(p.id);

    host.appendChild(row);
  });
}

function renderPlotsUI() {
  const host = el("plotsHost");
  host.innerHTML = "";

  graphBuilder.plots.forEach((pl, idx) => {
    const card = document.createElement("div");
    card.className = "plot-card";

    card.innerHTML = `
      <div class="small muted" style="margin-bottom:8px;">Plot ${idx + 1}</div>
      <div class="row">
        <input type="text" data-k="expr" placeholder="f(x) e.g. x^2" value="${pl.expr || ""}">
        <select data-k="style">
          <option value="thin">thin</option>
          <option value="thick">thick</option>
          <option value="very thick">very thick</option>
        </select>
        <button type="button" data-act="del">Delete</button>
      </div>
      <div class="small muted" style="margin-top:8px;">
        Tip: use x as the variable. Example: (x+1)^2 or 2(x-2)^2-3
      </div>
    `;

    const expr = card.querySelector('input[data-k="expr"]');
    const style = card.querySelector('select[data-k="style"]');
    const del = card.querySelector('button[data-act="del"]');

    style.value = pl.style || "thin";

    expr.oninput = () => { pl.expr = expr.value; drawGraphSvg(); };
    style.onchange = () => { pl.style = style.value; drawGraphSvg(); };


    del.onclick = () => {
      if (graphBuilder.plots.length <= 1) return; // keep at least one
      graphBuilder.plots = graphBuilder.plots.filter(x => x.id !== pl.id);
      renderPlotsUI();
    };

    host.appendChild(card);
  });
}

function tikzifyExpression(expr) {
  let s = (expr || "").trim();
  if (!s) return "\\x"; // harmless fallback

  // Insert multiplication for things like 2(x+1)
  s = s.replace(/(\d)\(/g, "$1*(");

  // Expand (x+1)^2 into (x+1)*(x+1) (TikZ-friendly)
  s = s.replace(/\(([^)]+)\)\^2/g, "($1)*($1)");

  // Replace x with \x for pgf math variable
  s = s.replace(/\bx\^2\b/g, "(\\x)*(\\x)");
  s = s.replace(/\bx\b/g, "\\x");

  return s;
}

function buildGraphTikzLatex() {
  // pull current form values
  graphBuilder.scale = Number(el("gScale").value);
  graphBuilder.pad = Number(el("gPad").value);
  graphBuilder.domMin = Number(el("gDomMin").value);
  graphBuilder.domMax = Number(el("gDomMax").value);
  graphBuilder.samples = Number(el("gSamples").value);

  const scale = graphBuilder.scale;
  const a = graphBuilder.a;
  const pad = graphBuilder.pad;

  // Single grid, multiple plots, multiple points
  const lines = [
    `\\begin{tikzpicture}[scale=${scale}]`,
    `\\def\\a{${a}}`,
    `\\def\\pad{${pad}}`,
    ``,
    `\\draw[step=1] (-\\a,-\\a) grid (\\a,\\a);`,
    `\\draw[<->, thick] (-\\a-\\pad,0)--(\\a+\\pad,0);`,
    `\\draw[<->, thick] (0,-\\a-\\pad)--(0,\\a+\\pad);`,
    ``
  ];

  // plots
  graphBuilder.plots.forEach(pl => {
    const style = (pl.style || "thin").trim();
    const expr = tikzifyExpression(pl.expr);
    lines.push(
      `\\draw[${style}, domain=${graphBuilder.domMin}:${graphBuilder.domMax}, samples=${graphBuilder.samples}, smooth]`,
      `  plot (\\x,{${expr}});`,
      ``
    );
  });

  // points
  graphBuilder.points.forEach(p => {
    lines.push(`\\filldraw (${p.x},${p.y}) circle (3pt);`);
    if (p.label) {
      // LaTeX math mode label
      lines.push(`\\node[${p.pos || "above right"}] at (${p.x},${p.y}) {$${p.label}$};`);
    }
  });

  lines.push(`\\end{tikzpicture}`);
  return lines.join("\n");
}

function insertGraphLatex() {
  const q = state.questions.find(x => x.id === state.selectedId);
  if (!q) return;

  const latex = buildGraphTikzLatex();
  const target = el("graphInsertTarget").value;

  if (target === "prompt") {
    el("qPrompt").value += "\n" + latex + "\n";
    q.prompt = el("qPrompt").value;
  } else {
    const idx = Number(target.replace("choice",""));
    clamp4Choices(q);
    q.choices[idx].text += "\n" + latex;
  }

  closeGraphModal();
  loadEditor(q.id);
}

// Wire interactive controls
function wireGraphUI() {
  el("btnUndoLine")?.addEventListener("click", undoLastLine);

  el("btnClearLines")?.addEventListener("click", () => {
    clearAllLines();
  });

  el("btnDeleteLine")?.addEventListener("click", () => {
    if (!graphBuilder.selectedLineId) return;
    deleteLineById(graphBuilder.selectedLineId);
  });

  // add plot
  el("btnAddPlot").addEventListener("click", () => {
    graphBuilder.plots.push({ id: uid("plot"), expr: "x^2", style: "thin" });
    renderPlotsUI();
  });

  // clear points
  el("btnClearPoints").addEventListener("click", () => {
    graphBuilder.points = [];
    graphBuilder.selectedPointId = null;
    el("pointEditor").style.display = "none";
    renderPointsUI();
    drawGraphSvg();
  });

  // point editor bindings
  el("pX").addEventListener("input", () => {
    const p = graphBuilder.points.find(x => x.id === graphBuilder.selectedPointId);
    if (!p) return;
    p.x = snap(Number(el("pX").value));
    drawGraphSvg(); renderPointsUI();
  });
  el("pY").addEventListener("input", () => {
    const p = graphBuilder.points.find(x => x.id === graphBuilder.selectedPointId);
    if (!p) return;
    p.y = snap(Number(el("pY").value));
    drawGraphSvg(); renderPointsUI();
  });
  el("pLabel").addEventListener("input", () => {
    const p = graphBuilder.points.find(x => x.id === graphBuilder.selectedPointId);
    if (!p) return;
    p.label = el("pLabel").value;
    drawGraphSvg(); renderPointsUI();
  });
  el("pPos").addEventListener("change", () => {
    const p = graphBuilder.points.find(x => x.id === graphBuilder.selectedPointId);
    if (!p) return;
    p.pos = el("pPos").value;
    drawGraphSvg(); renderPointsUI();
  });
  el("btnDeletePoint").addEventListener("click", () => {
    const pid = graphBuilder.selectedPointId;
    if (!pid) return;
    graphBuilder.points = graphBuilder.points.filter(x => x.id !== pid);
    graphBuilder.selectedPointId = null;
    el("pointEditor").style.display = "none";
    renderPointsUI();
    drawGraphSvg();
  });

  // grid size
  el("gPlus").addEventListener("click", () => {
    graphBuilder.a = clampA(graphBuilder.a + 1);
    updateAReadout();
    drawGraphSvg();
  });
  el("gMinus").addEventListener("click", () => {
    graphBuilder.a = clampA(graphBuilder.a - 1);
    updateAReadout();
    drawGraphSvg();
  });

  // pan (optional but feels good)
  el("gLeft").addEventListener("click", () => { graphBuilder.panX -= 1; drawGraphSvg(); });
  el("gRight").addEventListener("click", () => { graphBuilder.panX += 1; drawGraphSvg(); });
  el("gUp").addEventListener("click", () => { graphBuilder.panY += 1; drawGraphSvg(); });
  el("gDown").addEventListener("click", () => { graphBuilder.panY -= 1; drawGraphSvg(); });
}
  
wireGraphUI();


 function latexQuestionBlock(q) {
  const pts =
    (q.points !== "" && q.points !== null && q.points !== undefined)
      ? `[${q.points}] `
      : " ";

  const imgLines = (q.images || []).map(fn =>
    `\\begin{center}\n\\includegraphics{${escapeLatexUnsafe(fn)}}\n\\end{center}\n`
  ).join("");

  // INFO items (not questions)
  if (q.type === "info") {
    const scale = (q.infoImageScale || "0.75").trim() || "0.75";
    const imgs = (q.images || []).map(fn =>
      `\\includegraphics[scale=${scale}]{${escapeLatexUnsafe(fn)}}`
    ).join("\n");

    const innerInfo = [
      `\\begin{tcolorbox}[colback=white]`,
      `\\begin{center}`,
      escapeLatexUnsafe(q.prompt || ""),
      imgs ? imgs : "",
      `\\end{center}`,
      `\\end{tcolorbox}`
    ].filter(Boolean).join("\n");

    return [
      latexBlockHeader(q),
      innerInfo,
      ``
    ].join("\n");


  }

    // MULTIPLE CHOICE
  if (q.type === "multiple_choice") {
    clamp4Choices(q);

    const choiceLines = q.choices.map(ch => {
      const cmd = (ch.id === q.correctChoiceId) ? "\\CorrectChoice" : "\\choice";
      return `    ${cmd} ${escapeLatexUnsafe(ch.text)}`.trimEnd();
    }).join("\n");

    // Ensure numeric comparison works even if loaded from storage as string
    const cols = Number(q.mcColumns || 1);

    let choicesBody = choiceLines;
    if (cols === 2 || cols === 4) {
      choicesBody = [
        `\\begin{multicols}{${cols}}`,
        choiceLines,
        `\\end{multicols}`
      ].join("\n");
    }

    const innerMC = [
      imgLines,
      `\\question${pts}${escapeLatexUnsafe(q.prompt)}`,
      `\\begin{choices}`,
      choicesBody,
      `\\end{choices}`
    ].filter(Boolean).join("\n");

    return [
      latexBlockHeader(q),
      innerMC,
      ``
    ].join("\n");
  }


  // NUMERIC
  if (q.type === "numeric") {
    const ans = (q.numericAnswer || "").trim();

    const innerNum = [
      imgLines,
      `\\question${pts}${escapeLatexUnsafe(q.prompt)}`,
      `\\numbox`,
      ans ? `\\ifprintanswers\n\\textbf{Answer:} ${escapeLatexUnsafe(ans)}\n\\fi` : ``
    ].filter(Boolean).join("\n");

    return [
      latexBlockHeader(q),
      innerNum,
      ``
    ].join("\n");

  }

  // WRITTEN (default)
  const innerWritten = [
    imgLines,
    `\\question${pts}${escapeLatexUnsafe(q.prompt)}`
  ].filter(Boolean).join("\n");

  return [
    latexBlockHeader(q),
    innerWritten,
    ``
  ].join("\n");

}

function stripLatexNoise(s) {
  return (s || "")
    .replace(/\r/g, "")
    .replace(/^\s+|\s+$/g, "");
}

function extractAllIncludeGraphics(block) {
  const imgs = [];
  // matches \includegraphics{file} and \includegraphics[...]{file}
  const re = /\\includegraphics(?:\[[^\]]*?\])?\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(block)) !== null) {
    const fn = stripLatexNoise(m[1]);
    if (fn) imgs.push(fn);
  }
  return imgs;
}

function extractPoints(block) {
  // \question[3] or \question[3.5]
  const m = block.match(/\\question\s*\[([0-9]+(?:\.[0-9]+)?)\]/);
  return m ? Number(m[1]) : "";
}

function extractQuestionPrompt(block) {
  // Grab text after \question[pts] or \question up to newline or \begin{choices} or \numbox
  // This is intentionally conservative and assumes your generator puts prompt on same line.
  const m = block.match(/\\question(?:\s*\[[^\]]*\])?\s*([^\n]*)/);
  return m ? stripLatexNoise(m[1]) : "";
}

function extractChoices(block) {
  const choices = [];
  let correctIndex = 0;

  // isolate inside choices environment
  const env = block.match(/\\begin\{choices\}([\s\S]*?)\\end\{choices\}/);
  if (!env) return { choices, correctIndex };

  const lines = env[1].split("\n").map(x => x.trim()).filter(Boolean);

  for (const line of lines) {
    const mc = line.match(/^\\CorrectChoice\s*(.*)$/);
    const ch = line.match(/^\\choice\s*(.*)$/);

    if (mc) {
      correctIndex = choices.length;
      choices.push(stripLatexNoise(mc[1]));
    } else if (ch) {
      choices.push(stripLatexNoise(ch[1]));
    }
  }

  // enforce 4 choices like your builder expects
  while (choices.length < 4) choices.push("");
  if (choices.length > 4) choices.length = 4;

  return { choices, correctIndex };
}

function getQuestionsRegion(latex) {
  const src = (latex || "").replace(/\r/g, "");
  const m = src.match(/\\begin\{questions\}([\s\S]*?)\\end\{questions\}/);
  return m ? m[1] : src; // fallback: parse whole doc if no questions env
}

function stripLeadingCommentsAndSpace(s) {
  return (s || "")
    .replace(/^\s*%.*$/gm, "")
    .replace(/^\s+/, "");
}

function inferMcColumnsFromChoicesEnv(block) {
  // Detect \begin{multicols}{2} or {4} wrapping choices
  const m = block.match(/\\begin\{multicols\}\{(\d+)\}/);
  const n = m ? Number(m[1]) : 1;
  return (n === 2 || n === 4) ? n : 1;
}

function extractPromptMultiLine(block) {
  // Extract everything after \question[...] up to \begin{choices} or \numbox or end of block.
  // Keeps LaTeX (tables, graphs, etc.) in the prompt.
  const qMatch = block.match(/\\question(?:\s*\[[^\]]*\])?\s*/);
  if (!qMatch) return "";

  let rest = block.slice(qMatch.index + qMatch[0].length);

  // stop before choices/numbox
  const stopIdxs = [];
  const idxChoices = rest.search(/\\begin\{choices\}/);
  if (idxChoices >= 0) stopIdxs.push(idxChoices);

  const idxNum = rest.search(/\\numbox\b/);
  if (idxNum >= 0) stopIdxs.push(idxNum);

  const cut = stopIdxs.length ? Math.min(...stopIdxs) : rest.length;
  rest = rest.slice(0, cut);

  // Remove includegraphics blocks if you want them tracked separately (you already do)
  // We'll leave other LaTeX intact.
  rest = rest
    .replace(/\\begin\{center\}[\s\S]*?\\includegraphics[\s\S]*?\\end\{center\}\s*/g, "")
    .trim();

  // If prompt starts with a newline, trim it
  return stripLatexNoise(rest);
}

function parseQuestionsByQuestionCommand(latex) {
  const region = getQuestionsRegion(latex);
  const src = stripLeadingCommentsAndSpace(region);

  // Find every \question occurrence and split into blocks
  const re = /\\question(?:\s*\[[^\]]*\])?/g;
  const starts = [];
  let m;
  while ((m = re.exec(src)) !== null) starts.push(m.index);

  if (!starts.length) return [];

  const blocks = [];
  for (let i = 0; i < starts.length; i++) {
    const a = starts[i];
    const b = (i + 1 < starts.length) ? starts[i + 1] : src.length;
    blocks.push(src.slice(a, b).trim());
  }

  const questions = [];

  for (const block of blocks) {
    // classify
    // classify (STRICTER): only inspect content *after* \question
    const afterQuestion = block.replace(/^\\question(?:\s*\[[^\]]*\])?\s*/m, "");

    // MC: rely on choices environment (most reliable)
    const hasChoicesEnv = /\\begin\{choices\}/.test(afterQuestion);

    // Numeric: look for \numbox as a standalone command line (or at least as a command)
    const hasNumBox = /(^|[\s\}])\\numbox\b/m.test(afterQuestion);

    // Final classification
    const isMC = hasChoicesEnv;
    const isNumeric = !isMC && hasNumBox; // MC wins if both appear


    const q = {
      id: uid("q"), // no QBLOCK id available; generate fresh
      type: "written",
      points: "",
      prompt: "",
      images: [],
      shuffleSelected: true,
      choices: null,
      correctChoiceId: null,
      numericAnswer: "",
      infoImageScale: "0.75",
      selected: false,
      groupId: null,
      mcColumns: 1,
    };

    // images (your existing extractor)
    q.images = extractAllIncludeGraphics(block);

    // points (your existing extractor)
    q.points = extractPoints(block);

    if (isMC) {
      q.type = "multiple_choice";
      q.prompt = extractPromptMultiLine(block);

      const { choices, correctIndex } = extractChoices(block);
      q.choices = choices.map(text => ({ id: uid("c"), text }));
      q.correctChoiceId = q.choices[Math.max(0, Math.min(3, correctIndex))].id;

      q.mcColumns = inferMcColumnsFromChoicesEnv(block);

    } else if (isNumeric) {
      q.type = "numeric";
      q.prompt = extractPromptMultiLine(block);
      q.numericAnswer = extractNumericAnswer(block);

    } else {
      q.type = "written";
      q.prompt = extractPromptMultiLine(block);
    }

    questions.push(q);
  }

  return questions;
}

function parseQuestionsSmart(latex) {
  const src = (latex || "").replace(/\r/g, "");

  // If it looks like your tool output (QBLOCK markers), keep your robust path.
  if (/^\s*%==QBLOCK\b/m.test(src)) {
    return parseQuestionsFromLatex(src); // your existing function
  }

  // Otherwise, fallback to parsing by \question
  return parseQuestionsByQuestionCommand(src);
}



function extractNumericAnswer(block) {
  // looks for \textbf{Answer:} ... inside \ifprintanswers ... \fi
  const m = block.match(/\\textbf\{Answer:\}\s*([^\n\\]+)[\s\S]*?\\fi/);
  return m ? stripLatexNoise(m[1]) : "";
}

function inferInfoImageScale(block) {
  // tries to pick scale from \includegraphics[scale=0.75]{...}
  const m = block.match(/\\includegraphics\[\s*scale\s*=\s*([0-9]*\.?[0-9]+)\s*\]\{/);
  return m ? stripLatexNoise(m[1]) : "0.75";
}

function extractInfoPrompt(block) {
  // try to capture what your generator emits inside center, before includegraphics.
  // We’ll take the first non-command text line inside the center environment.
  const center = block.match(/\\begin\{center\}([\s\S]*?)\\end\{center\}/);
  if (!center) return "";

  const raw = center[1]
    // remove includegraphics lines
    .replace(/\\includegraphics[\s\S]*?\}\s*/g, "")
    // remove obvious env commands
    .replace(/\\(begin|end)\{[^\}]+\}/g, "")
    .trim();

  // Keep first meaningful line
  const lines = raw.split("\n").map(x => x.trim()).filter(Boolean);
  return lines.length ? lines[0] : "";
}

function parseQuestionsFromLatex(latex) {
  const src = (latex || "").replace(/\r/g, "");
  const blocks = [];

  // split into QBLOCK blocks (recommended, robust)
const parts = src.split(/^\s*%==QBLOCK\b/m);

// parts[0] is anything before the first block; ignore it
for (let i = 1; i < parts.length; i++) {
  const chunk = parts[i];

  // First line looks like: " id=q_xxx=="
  const firstLine = (chunk.split("\n")[0] || "").trim();
  const idMatch = firstLine.match(/id=([^\s=]+)==/);
  const blockId = idMatch ? idMatch[1] : uid("q");

  const cleaned = chunk.replace(/^[^\n]*\n/, ""); // drop header line
  const b = cleaned.trim();
  if (b) blocks.push({ id: blockId, body: b });
}



  const questions = [];

for (const entry of blocks) {
  const block = entry.body.trim();

  // classify
  const isInfo = /\\begin\{tcolorbox\}/.test(block);
  const isMC = /\\begin\{choices\}/.test(block);
  const isNumeric = /\\numbox/.test(block);

  const q = {
    id: entry.id,              // IMPORTANT: keep the ID from the QBLOCK header
    type: "written",
    points: "",
    prompt: "",
    images: [],
    shuffleSelected: true,
    choices: null,
    correctChoiceId: null,
    numericAnswer: "",
    infoImageScale: "0.75",
    selected: false,
    groupId: null,
    mcColumns: 1,
  };

  // images
  const imgs = extractAllIncludeGraphics(block);

  if (isInfo) {
    q.type = "info";
    q.prompt = extractInfoPrompt(block);
    q.images = imgs;
    q.infoImageScale = inferInfoImageScale(block);
    q.points = "";
  } else if (isMC) {
    q.type = "multiple_choice";
    q.points = extractPoints(block);
    q.prompt = extractQuestionPrompt(block);
    q.images = imgs;

    const { choices, correctIndex } = extractChoices(block);
    q.choices = choices.map(text => ({ id: uid("c"), text }));
    q.correctChoiceId = q.choices[Math.max(0, Math.min(3, correctIndex))].id;
  } else if (isNumeric) {
    q.type = "numeric";
    q.points = extractPoints(block);
    q.prompt = extractQuestionPrompt(block);
    q.images = imgs;
    q.numericAnswer = extractNumericAnswer(block);
  } else {
    q.type = "written";
    q.points = extractPoints(block);
    q.prompt = extractQuestionPrompt(block);
    q.images = imgs;
  }

  questions.push(q);
}

return questions;

}


  function generateLatex() {
  const mode = (el("docMode")?.value || "test"); // "test" or "quiz"

  const testName = el("testName")?.value || "TITLE GOES HERE";
  const gradeSubject = el("gradeSubject")?.value || "Grade and Subject goes here";
  const headerImage = el("headerImage")?.value || "Stem Header.png";

  const instructionsLines = (el("instructions")?.value || "")
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);

  const instructionItems = instructionsLines.length
    ? instructionsLines.map(x => `       \\item ${escapeLatexUnsafe(x)}`).join("\n")
    : `       \\item Put your test rules in here eg.\n       \\item No Calculators`;

  // Build question blocks from your current question list
  const questionsLatex = state.questions.map(q => latexQuestionBlock(q)).join("\n");

  let out = "";

  if (mode === "quiz") {
    // QUIZ FORMAT (compact header)
    out =
`\\documentclass[10pt]{exam}
\\usepackage{tikz}
\\usepackage{amsmath, amssymb}
\\usepackage[margin=1in]{geometry}
\\usepackage{tikz-3dplot} % For 3D projections
\\tdplotsetmaincoords{70}{110}
\\usepackage{multicol}
\\usepackage{graphicx}
\\usepackage{pgfplots}
\\usepackage{needspace}
\\usepackage{amssymb}
\\graphicspath{ {./images/} }
\\usepackage{tcolorbox}
\\pointsinmargin

\\def\\numbox{
\\begin{center}
\\begin{tikzpicture}
\\draw (0,0) rectangle (1,1);
\\draw (0,0) rectangle (2,1);
\\draw (0,0) rectangle (3,1);
\\draw (0,0) rectangle (4,1);
\\end{tikzpicture}
\\end{center}
}

% Function plot helper (requires pgfplots)
\\def\\drawfunction#1#2#3#4#5#6#7{%
\\begin{tikzpicture}[scale=#7]
\\begin{axis}[
    axis lines = center,
    xmin = #1, xmax = #2,
    ymin = #3, ymax = #4,
    grid = both,
    major grid style = {line width=0.8pt, gray!60},
    minor grid style = {line width=0.4pt, gray!30},
    xlabel = $x$,
    ylabel = $y$,
    samples = 200,
    xtick distance = #5,
    ytick distance = #5
]
\\addplot[thick, black] {#6};
\\end{axis}
\\end{tikzpicture}
}


\\begin{document}

\\begin{center}
  \\textbf{\\Large ${escapeLatexUnsafe(testName)}}
\\end{center}
\\vspace{0.5cm}
Name: \\underline{\\hspace{6cm}} \\hspace{5cm} Date: \\underline{\\hspace{4cm}}
\\vspace{1cm}

% Questions go in here. use the format \\question[# of points] Question text here
\\begin{questions}
${questionsLatex}
\\end{questions}

\\end{document}
`;
  } else {
    // TEST FORMAT (your current full title page)
    out =
`\\documentclass[10pt, addpoints]{exam}
\\addpoints
\\usepackage{amsmath}
\\usepackage{tikz}
\\usepackage{pgfplots}
\\usepackage{multicol}
\\usepackage{tcolorbox}
\\usepackage{graphicx}
\\usepackage{amssymb}

\\graphicspath{ {./images/} }
\\pointsinmargin

\\usepackage{needspace}
\\usepackage{etoolbox}

\\def\\numbox{
\\begin{center}
\\begin{tikzpicture}
\\draw (0,0) rectangle (1,1);
\\draw (0,0) rectangle (2,1);
\\draw (0,0) rectangle (3,1);
\\draw (0,0) rectangle (4,1);
\\end{tikzpicture}
\\end{center}
}


% Function plot helper (requires pgfplots)
\\def\\drawfunction#1#2#3#4#5#6#7{%
\\begin{tikzpicture}[scale=#7]
\\begin{axis}[
    axis lines = center,
    xmin = #1, xmax = #2,
    ymin = #3, ymax = #4,
    grid = both,
    major grid style = {line width=0.8pt, gray!60},
    minor grid style = {line width=0.4pt, gray!30},
    xlabel = $x$,
    ylabel = $y$,
    samples = 200,
    xtick distance = #5,
    ytick distance = #5
]
\\addplot[thick, black] {#6};
\\end{axis}
\\end{tikzpicture}
}


\\begin{document}

% Title Page
\\begin{center}

    \\vspace{2cm}
    \\includegraphics{${escapeLatexUnsafe(headerImage)}}

\\vspace{1cm}
    \\Huge\\textbf{${escapeLatexUnsafe(testName)}}

    \\vspace{1cm}
    \\large\\textbf{${escapeLatexUnsafe(gradeSubject)}}

    \\vspace{2cm}
    \\large
    \\begin{tabbing}
    Name: \\underline{\\hspace{8cm}} \\\\
    Date: \\underline{\\hspace{8cm}}
    \\end{tabbing}

    \\vspace{1cm}
    \\textbf{Instructions:}
    \\vspace{0.5cm}

    \\begin{itemize}
${instructionItems}
    \\end{itemize}

\\vspace{1cm}
 \\begin{center}
    \\fbox{\\textbf{Total Points for this Exam: \\numpoints}}
\\end{center}

\\end{center}

\\newpage
\\begin{center} \\textbf{ Multiple Choice} \\end{center}

\\begin{questions}

% Questions go here.
${questionsLatex}
\\end{questions}

\\end{document}
`;
  }

  el("latexOut").value = out;
  renderMapping();
}


  function renderMapping() {
    const container = el("mappingOut");
    if (!state.questions.length) {
      container.innerHTML = `<div class="small muted">No questions.</div>`;
      return;
    }

      let qNum = 0;
  const rows = state.questions.map((q) => {
    let label = "";
    let ans = "";

    if (q.type === "info") {
      label = "INFO";
      ans = "—";
    } else {
      qNum++;
      label = "Q" + qNum;

      if (q.type === "multiple_choice") {
        clamp4Choices(q);
        const idx = q.choices.findIndex(c => c.id === q.correctChoiceId);
        ans = ["A","B","C","D"][Math.max(0, idx)];
      } else if (q.type === "numeric") {
        ans = (q.numericAnswer && q.numericAnswer.trim()) ? q.numericAnswer.trim() : "(no answer)";
      } else {
        ans = "(written)";
      }
    }

    const promptPreview = (q.prompt || "").replace(/\s+/g, " ").trim().slice(0, 60);

    return `<tr>
      <td>${label}</td>
      <td>${q.type.replace("_"," ")}</td>
      <td>${promptPreview}${(q.prompt||"").length>60?"…":""}</td>
      <td>${ans}</td>
    </tr>`;
  }).join("");


    container.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>Rendered #</th>
            <th>Type</th>
            <th>Prompt (preview)</th>
            <th>Answer (MC)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function clientToSvg(svg, clientX, clientY) {
  const pt = svg.createSVGPoint();
  pt.x = clientX;
  pt.y = clientY;
  const ctm = svg.getScreenCTM();
  if (!ctm) return { x: 0, y: 0 };
  const p = pt.matrixTransform(ctm.inverse());
  return { x: p.x, y: p.y }; // in viewBox units (0..600)
}

  function refreshAfterReorder() {
    // Update the right-side mapping panel
    renderMapping();

    // If a snapshot exists, update the shuffle tracking panel too
    const sid = latestSnapshotId();
    if (sid) renderShuffleMap(sid);

    // Optional but recommended: persist order changes
    saveToCache();
  }

  async function copyLatex() {
    const txt = el("latexOut").value;
    if (!txt) return;
    await navigator.clipboard.writeText(txt);
    el("btnCopy").textContent = "Copied";
    setTimeout(() => el("btnCopy").textContent = "Copy LaTeX", 900);
  }

  // Buttons
  el("btnAddMC").addEventListener("click", () => createQuestion("multiple_choice"));
  el("btnAddNum").addEventListener("click", () => createQuestion("numeric"));
  el("btnAddWritten").addEventListener("click", () => createQuestion("written"));

  el("btnSave").addEventListener("click", saveEdits);
  el("btnDelete").addEventListener("click", deleteSelected);
  el("btnDuplicate").addEventListener("click", duplicateSelected);
  el("btnShuffleSelected").addEventListener("click", shuffleSelected);
  el("btnShuffleAll").addEventListener("click", shuffleAll);
  el("btnGenerate").addEventListener("click", generateLatex);
  el("btnCopy").addEventListener("click", copyLatex);
  el("btnGroupSelected").addEventListener("click", groupSelected);
  el("btnUngroupSelected").addEventListener("click", ungroupSelected);
  el("btnShuffleWithinGroups").addEventListener("click", () => shuffleWithinGroups());

  el("btnAddInfo").addEventListener("click", () => createQuestion("info"));

  el("mcColumns").addEventListener("change", () => {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q || q.type !== "multiple_choice") return;

    const v = Number(el("mcColumns").value);
    q.mcColumns = (v === 2 || v === 4) ? v : 1;
  });

  // Table Builder wiring
  el("btnOpenTableBuilder").addEventListener("click", openTableModal);

  el("btnCloseTableModal").addEventListener("click", closeTableModal);
  el("btnAddTableCol").addEventListener("click", addTableColumn);
  el("btnAddTableRow").addEventListener("click", addTableRow);
  el("btnRemoveTableCol").addEventListener("click", removeTableColumn);
  el("btnRemoveTableRow").addEventListener("click", removeTableRow);
  el("btnInsertTableLatex").addEventListener("click", () => {
    insertTableLatex();
    closeTableModal();
  });



  el("qType").addEventListener("change", () => {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q) return;
    q.type = el("qType").value;
    if (q.type === "multiple_choice") clamp4Choices(q);
    loadEditor(q.id);
    renderList();
  });

  el("btnClearSaved").addEventListener("click", () => {
  clearCache();
  // Optional: also clear current session
  state.questions = [];
  state.selectedId = null;
  renderList();
  loadEditor(null);
  });

  el("btnSaveKey").addEventListener("click", saveKeySnapshot);
  el("btnShowShuffleMap").addEventListener("click", () => {
  const sid = latestSnapshotId();
  if (!sid) return;
  renderShuffleMap(sid);
  });

  // Graph Builder wiring
  el("btnOpenGraphBuilder").addEventListener("click", openGraphModal);
  el("btnCloseGraphModal").addEventListener("click", closeGraphModal);
  el("btnInsertGraphLatex").addEventListener("click", insertGraphLatex);

  el("btnToolPoint").addEventListener("click", () => {
  graphBuilder.tool.mode = "point";
  graphBuilder.tool.lineStart = null;
  drawGraphSvg();
});

el("btnToolLine").addEventListener("click", () => {
  graphBuilder.tool.mode = "line";
  graphBuilder.tool.lineStart = null;
  drawGraphSvg();
});

el("btnToggleGrid").addEventListener("click", () => {
  graphBuilder.showGrid = !graphBuilder.showGrid;
  drawGraphSvg();
});




    // HOME / IMPORT wiring
  el("btnGoNew").addEventListener("click", () => {
    // Start fresh
    state.questions = [];
    state.selectedId = null;
    saveToCache();
    renderList();
    loadEditor(null);
    showBuilder();
  });

  el("btnGoImport").addEventListener("click", () => {
    el("importArea").style.display = "block";
  });

  el("btnCancelImport").addEventListener("click", () => {
    el("importArea").style.display = "none";
    el("importLatex").value = "";
  });

  el("btnDoImport").addEventListener("click", () => {
  const latex = el("importLatex").value || "";
  const parsed = parseQuestionsSmart(latex);

  if (!parsed.length) {
    alert("No questions found. Paste either:\n(1) LaTeX generated by this tool (with %==QBLOCK markers), or\n(2) Any LaTeX that uses \\question for each question.");
    return;
  }

  state.questions = parsed;
  state.selectedId = parsed[0].id;

  renderList();
  loadEditor(state.selectedId);
  saveToCache();

  el("importLatex").value = "";
  el("importArea").style.display = "none";

  showBuilder();
});


  // Drag-and-drop reorder
  new Sortable(el("qList"), {
  draggable: ".qcard, .qgroup",
  handle: ".handle",
  animation: 150,

  onEnd: () => {
    // Rebuild state.questions based on the DOM order after drag.
    const list = el("qList");

    const byId = new Map(state.questions.map(q => [q.id, q]));
    const rebuilt = [];

    [...list.children].forEach(node => {
      if (node.classList.contains("qcard")) {
        const id = node.dataset.id;
        const q = byId.get(id);
        if (q) rebuilt.push(q);
        return;
      }

      if (node.classList.contains("qgroup")) {
        const cards = node.querySelectorAll(".qcard");
        cards.forEach(card => {
          const id = card.dataset.id;
          const q = byId.get(id);
          if (q) rebuilt.push(q);
        });
      }
    });

    // Only commit if we rebuilt the full list
    if (rebuilt.length === state.questions.length) {
      state.questions = rebuilt;
    }

    renderList();
    loadEditor(state.selectedId);
    refreshAfterReorder();
  }
});


loadFromCache();
renderList();

if (state.questions.length) {
  // Resume existing work
  showBuilder();
  if (state.selectedId) {
    loadEditor(state.selectedId);
  } else if (state.questions[0]) {
    state.selectedId = state.questions[0].id;
    loadEditor(state.selectedId);
  }
} else {
  // Fresh start
  showHome();
}


})();

</script>
</body>
</html>
