<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LaTeX Test Builder</title>

  <link rel="stylesheet" href="style_pro.css">

  <!-- SortableJS for drag-and-drop -->
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.2/Sortable.min.js"></script>
</head>

<body>

  <!-- HOME SCREEN -->
  <div id="homeScreen" class="panel" style="max-width:1000px; margin:20px auto;">
    <div class="hd">
      <div class="title">LaTeX Test Builder</div>
    </div>

    <div class="bd">
      <div class="btnrow" style="margin-bottom:12px;">
        <button class="ok" id="btnGoNew">Generate New</button>
        <button id="btnGoImport">Generate from LaTeX</button>
      </div>

      <div id="importArea" style="display:none;">
        <div class="field">
          <label>Paste LaTeX generated by this tool</label>
          <textarea
            id="importLatex"
            spellcheck="false"
            style="min-height:220px;"
            placeholder="Paste the LaTeX here (must include the \begin{samepage} blocks)."
          ></textarea>

          <div class="small muted">
            Import assumes the structure produced by this builder: each question wrapped in samepage, with choices/numbox/tcolorbox patterns.
          </div>
        </div>

        <div class="btnrow">
          <button class="primary" id="btnDoImport">Import and Open Builder</button>
          <button id="btnCancelImport">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- BUILDER SCREEN -->
  <div id="builderScreen" style="display:none;">
    <header>
      <h1>Exam (LaTeX) Test Builder</h1>
      <p>Client-side tool: build questions, reorder/shuffle, and copy/paste LaTeX into Overleaf.</p>
    </header>

    <div class="app">
      <!-- LEFT: Question list -->
      <div class="panel">
        <div class="hd">
          <div class="title">Questions</div>
          <div class="muted" id="qCount">0</div>
        </div>

        <div class="bd">
          <div class="btnrow" style="margin-bottom:10px;">
            <button class="btn-add" id="btnAddMC">Add MC</button>
            <button class="btn-add" id="btnAddNum">Add Numeric</button>
            <button class="btn-add" id="btnAddWritten">Add Written</button>
            <button class="btn-add" id="btnAddInfo">Add Info</button>
            <button class="btn-shuffle" id="btnShuffleSelected">Shuffle Selected</button>
            <button class="btn-shuffle" id="btnShuffleAll">Shuffle All</button>
            <button class="btn-shuffle" id="btnShuffleWithinGroups">Shuffle Within Groups</button>
            <button class="btn-group" id="btnGroupSelected">Group Selected</button>
            <button class="btn-group" id="btnUngroupSelected">Ungroup Selected</button>
            <button id="btnClearSaved">Clear Saved</button>
          </div>

          <div class="small">Drag the handle on a question card to reorder.</div>
          <div class="hr"></div>
          <div class="qlist" id="qList"></div>
        </div>
      </div>

      <!-- RIGHT: Editor + Output -->

<div class="panel">
  <div class="hd">
    <div class="title">Editor & Output</div>

    <div class="btnrow">
      <label class="small muted" style="display:flex; align-items:center; gap:8px; margin-right:10px;">
        Format:
        <select id="docMode" style="width:auto; min-width:140px;">
          <option value="test" selected>Test</option>
          <option value="quiz">Quiz</option>
        </select>
      </label>

      <button class="ok" id="btnGenerate">Generate LaTeX</button>
      <button id="btnCopy">Copy LaTeX</button>
      <button id="btnSaveKey">Save Key Snapshot</button>
      <button id="btnShowShuffleMap">Show Shuffle Map</button>
    </div>
  </div>

  <div class="bd">
    <div class="grid2">
      <!-- Test settings -->
        <div>
          <div class="field">
            <label>Test name (Title page)</label>
            <input type="text" id="testName" placeholder="e.g., Unit 3 Test" />
          </div>
          <div class="field">
            <label>Grade and Subject</label>
            <input type="text" id="gradeSubject" placeholder="e.g., Grade 10 Science" />
          </div>
          <div class="field">
            <label>Header image filename (in Overleaf images/ folder)</label>
            <input type="text" id="headerImage" value="Stem Header.png" />
            <div class="small">Overleaf: put the image inside <code>images/</code>. Your LaTeX already has <code>\graphicspath{ {./images/} }</code>.</div>
          </div>
          <div class="field">
            <label>Instructions (one per line)</label>
            <textarea id="instructions" placeholder="No calculators&#10;Show all work"></textarea>
          </div>
          <div class="hr"></div>

          <!-- Question editor -->
          <div class="field">
            <label>Selected Question</label>
            <div class="small" id="selectedInfo">No question selected. Click a question card on the left.</div>
          </div>

          <div id="editorArea" style="display:none;">
            <div class="grid2">
              <div class="field">
                <label>Type</label>
                <select id="qType">
                  <option value="multiple_choice">Multiple Choice</option>
                  <option value="numeric">Numeric Response</option>
                  <option value="written">Written Response</option>
                  <option value="info">Info Box </option>
                </select>
              </div>
              <div class="field">
                <label>Points (optional)</label>
                <input type="number" id="qPoints" min="0" step="1" placeholder="e.g., 3" />
              </div>
            </div>

            <div class="field">
              <label>Question prompt (LaTeX allowed)</label>
              <textarea id="qPrompt" placeholder="Type the question here..."></textarea>
            </div>

            <div class="btnrow" style="margin-top:8px;">
              <button type="button" id="btnOpenTableBuilder">Table Builder</button>
              <button type="button" id="btnOpenGraphBuilder">Graph Builder</button>
            </div>

            <div class="field">
              <label>Image filename(s) (optional, one per line; must exist in images/ folder)</label>
              <textarea id="qImages" placeholder="diagram1.png&#10;photo2.jpg"></textarea>
              <div class="small">Each will be inserted as <code>\includegraphics{...}</code> above the question text.</div>
            </div>
            
            <!-- Numeric-only fields -->
            <div id="numericArea" style="display:none;">
              <div class="grid2">
                <div class="field">
                  <label>Numeric answer (shown only when you compile with \printanswers)</label>
                  <input type="text" id="numAnswer" placeholder="e.g., 9.8 m/s^2" />
                </div>
              </div>
            </div>



            <div id="mcArea">
              <div class="field">
                <label style="display:block;">Multiple choice options (4) and correct answer</label>
                <div class="choices" id="mcChoices" style="margin-top:10px;"></div>
                <div class="small">Use this to create a matrix-style choice table and insert it into the prompt or a choice.</div>
              </div>
            </div>

            <div class="field" id="mcColumnsField">
              <label>Answer choice columns</label>
              <select id="mcColumns">
                <option value="1">1 column</option>
                <option value="2">2 columns</option>
                <option value="4">4 columns</option>
              </select>
            </div>


            <div class="btnrow">
              <button class="primary" id="btnSave">Apply Changes</button>
              <button class="danger" id="btnDelete">Delete Question</button>
              <button id="btnDuplicate">Duplicate</button>
            </div>
          </div>
        </div>

        <!-- Output -->
        <div class="outwrap">
          <div class="field">
            <label>Generated LaTeX (.tex)</label>
            <textarea id="latexOut" spellcheck="false" placeholder="Click “Generate LaTeX” to populate..."></textarea>
          </div>

          <div class="field">
            <label>Mapping / Answer Key (for your reference)</label>
            <div id="mappingOut" class="panel" style="border-radius:10px; padding:10px; background: var(--panel2); border:1px solid var(--border);">
              <div class="small muted">Generate LaTeX to refresh mappings.</div>
            </div>
            <div class="small">This mapping is not inserted into the student test; it is for teachers to verify shuffles/reorders.</div>
          </div>

          <div class="field">
            <label>Shuffle Tracking (Saved Key → Current Order)</label>
            <div id="shuffleMapOut" class="panel" style="border-radius:10px; padding:10px; background: var(--panel2); border:1px solid var(--border);">
              <div class="small muted">Save a key snapshot, then shuffle/reorder to see movements.</div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Table Builder Modal -->
<div id="tableModal" class="tb-modal">
  <div class="tb-modal-card">
    <div class="tb-modal-hd">
      <div style="font-weight:600;">Table Builder</div>
      <button type="button" id="btnCloseTableModal">Close</button>
    </div>

    <div class="tb-modal-bd">
      <div class="btnrow" style="margin-bottom:10px;">
        <button type="button" id="btnAddTableCol">Add Column</button>
        <button type="button" id="btnAddTableRow">Add Row</button>
        <button type="button" id="btnRemoveTableCol">Remove Column</button>
        <button type="button" id="btnRemoveTableRow">Remove Row</button>

        <div style="margin-left:auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <label class="small muted">Insert into:</label>
          <select id="tableInsertTarget">
            <option value="prompt">Question Prompt</option>
            <option value="choice0">Choice A</option>
            <option value="choice1">Choice B</option>
            <option value="choice2">Choice C</option>
            <option value="choice3">Choice D</option>
          </select>
          <button type="button" class="primary" id="btnInsertTableLatex">Insert LaTeX</button>
        </div>
      </div>

      <div class="small muted" style="margin-bottom:10px;">
        Click into any cell to type. Add/remove by using Add Row/Column. (Row labels remain A., B., C., … automatically.)
      </div>

      <div id="tableBuilderHost" class="tb-host"></div>

      <div class="small muted" style="margin-top:10px;">
        Tip: If you insert into the prompt, set the four choices to just “A”, “B”, “C”, “D” (or leave blank text).
      </div>
    </div>
  </div>
</div>




<!-- Graph Builder Modal -->
<div id="graphModal" class="tb-modal">
  <div class="tb-modal-card" style="max-width:860px;">
    <div class="tb-modal-hd">
      <div style="font-weight:600;">Graph Builder (Function Plot)</div>
      <button type="button" id="btnCloseGraphModal">Close</button>
    </div>

    



    <div class="tb-modal-bd">
      <div class="grid2">

        <div class="field" style="max-width:90px;">
          <label>Scale</label>
          <input
            type="number"
            id="gScale"
            value="1"
            step="0.1"
            min="0.1"
            style="text-align:center;"
          >
        </div>

        <div class="field">
          <label>x min</label>
          <input type="number" id="gXMin" value="-5" step="0.5">
        </div>
        <div class="field">
          <label>x max</label>
          <input type="number" id="gXMax" value="5" step="0.5">
        </div>

        <div class="field">
          <label>y min</label>
          <input type="number" id="gYMin" value="-5" step="0.5">
        </div>
        <div class="field">
          <label>y max</label>
          <input type="number" id="gYMax" value="5" step="0.5">
        </div>

        <div class="field">
          <label>Grid step (tick distance)</label>
          <input type="number" id="gStep" value="1" step="0.5" min="0.1">
        </div>

        <div class="field">
          <label>Insert into</label>
          <select id="graphInsertTarget">
            <option value="prompt">Question Prompt</option>
            <option value="choice0">Choice A (MC only)</option>
            <option value="choice1">Choice B (MC only)</option>
            <option value="choice2">Choice C (MC only)</option>
            <option value="choice3">Choice D (MC only)</option>
          </select>
          <div class="small muted">Choices only apply when the selected item is Multiple Choice.</div>
        </div>
      </div>

      <div class="field">
        <label>Function (pgfplots expression)</label>
        <input type="text" id="gFunc" value="x^2" placeholder="e.g., x^2 - 3*x + 2 or sin(deg(x))">
        <div class="small muted">
          Use pgfplots expressions. Examples: <code>x^2</code>, <code>sin(deg(x))</code>, <code>exp(x)</code>.
        </div>
      </div>

      <div class="btnrow" style="justify-content:flex-end;">
        <button type="button" class="primary" id="btnInsertGraphLatex">Insert LaTeX</button>
      </div>
    </div>
  </div>
</div>



<script>
(() => {
  const state = {
  questions: [],
  selectedId: null,
  savedKeys: [] // array of snapshots
  };


  const el = (id) => document.getElementById(id);

  function showHome() {
  el("homeScreen").style.display = "block";
  el("builderScreen").style.display = "none";
}

function showBuilder() {
  el("homeScreen").style.display = "none";
  el("builderScreen").style.display = "block";
}


  function uid(prefix="q") {
    return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }

  function escapeLatexUnsafe(str) {
    return str ?? "";
  }

  function clamp4Choices(q) {
    if (!q.choices || q.choices.length !== 4) {
      q.choices = [
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" }
      ];
    }
    if (!q.correctChoiceId) q.correctChoiceId = q.choices[0].id;
  }

  function renderQuestionCard(q, idx, parent) {
    const card = document.createElement("div");
    card.className = "qcard" + (q.id === state.selectedId ? " active" : "");
    card.dataset.id = q.id;

    const handle = document.createElement("div");
    handle.className = "handle";
    handle.textContent = "≡";

    const meta = document.createElement("div");
    meta.className = "qmeta";

    const top = document.createElement("div");
    top.className = "topline";

    const badge = document.createElement("span");
    badge.className = "badge";
    badge.textContent = q.type.replace("_"," ").toUpperCase();

    const idxSpan = document.createElement("span");
    idxSpan.className = "badge";
    if (q.type === "info") {
      idxSpan.textContent = "INFO";
    } else {
      idxSpan.textContent = "Q" + questionNumberUpTo(idx);
    }

    top.appendChild(badge);
    top.appendChild(idxSpan);

    const prev = document.createElement("div");
    prev.className = "qpreview";
    const previewText = (q.prompt || "").replace(/\s+/g," ").trim();
    prev.textContent = previewText
      ? previewText.slice(0,70) + (previewText.length > 70 ? "…" : "")
      : "(no prompt yet)";

    const actions = document.createElement("div");
    actions.className = "qactions";

    const lbl = document.createElement("label");
    const cb = document.createElement("input");
    cb.type = "checkbox";
    cb.checked = !!q.selected;
    cb.addEventListener("change", e => q.selected = e.target.checked);

    lbl.appendChild(cb);
    lbl.appendChild(document.createTextNode("Selected"));
    actions.appendChild(lbl);

    meta.appendChild(top);
    meta.appendChild(prev);
    meta.appendChild(actions);

    card.appendChild(handle);
    card.appendChild(meta);

    card.addEventListener("click", e => {
      if (e.target.tagName === "INPUT") return;
      state.selectedId = q.id;
      renderList();
      loadEditor(q.id);
    });

    parent.appendChild(card);
  }



  function questionNumberUpTo(index) {
  let n = 0;
  for (let k = 0; k <= index; k++) {
    if (state.questions[k].type !== "info") n++;
  }
  return n;
  }

  function getDisplayedLabelAtIndex(index) {
    const q = state.questions[index];
    if (!q) return "";
    if (q.type === "info") return "INFO";
    return "Q" + questionNumberUpTo(index);
  }


  function renderList() {
    const list = el("qList");
    list.innerHTML = "";

    let i = 0;

    while (i < state.questions.length) {
      const q = state.questions[i];

      // Not grouped: render directly
      if (!q.groupId) {
        renderQuestionCard(q, i, list);
        i++;
        continue;
      }

      // Grouped: wrap contiguous items in qgroup container
      const gid = q.groupId;
      const groupDiv = document.createElement("div");
      groupDiv.className = "qgroup";
      groupDiv.dataset.gid = gid;

      // Group handle so the whole block is draggable
      const gHandle = document.createElement("div");
      gHandle.className = "handle groupHandle";
      gHandle.textContent = "≡ GROUP";
      groupDiv.appendChild(gHandle);


      let j = i;
      while (j < state.questions.length && state.questions[j].groupId === gid) {
        renderQuestionCard(state.questions[j], j, groupDiv);
        j++;
      }

      list.appendChild(groupDiv);
      i = j;
    }

    el("qCount").textContent = state.questions.length.toString();
  }


  function loadEditor(qid) {
    const q = state.questions.find(x => x.id === qid);
    if (!q) {
      el("selectedInfo").textContent = "No question selected.";
      el("editorArea").style.display = "none";
      return;
    }
    const idx = state.questions.indexOf(q);
    el("selectedInfo").textContent =
      `Editing ${qid} (rendered position: ${q.type === "info" ? "INFO" : ("Q" + questionNumberUpTo(idx))})`;
    el("editorArea").style.display = "block";

    el("qType").value = q.type;
    el("qPoints").value = (q.points ?? "") === null ? "" : (q.points ?? "");
    el("qPrompt").value = q.prompt ?? "";
    el("qImages").value = (q.images ?? []).join("\n");

        // Hide points for Info items (not a question)
    if (q.type === "info") {
      el("qPoints").value = "";
      el("qPoints").disabled = true;
    } else {
      el("qPoints").disabled = false;
    }

    if (q.type === "multiple_choice") {
      el("mcArea").style.display = "block";
      el("mcColumnsField").style.display = "block";

      clamp4Choices(q);
      renderMCChoices(q);

      el("mcColumns").value = q.mcColumns || 1;
    } else {
      el("mcArea").style.display = "none";
      el("mcColumnsField").style.display = "none";
    }



    // Numeric-only editor area
    if (q.type === "numeric") {
      el("numericArea").style.display = "block";
      el("numAnswer").value = q.numericAnswer || "";
    } else {
      el("numericArea").style.display = "none";
    }


  }

  function renderMCChoices(q) {
    const box = el("mcChoices");
    box.innerHTML = "";
    const letters = ["A", "B", "C", "D"];

    q.choices.forEach((ch, i) => {
      const row = document.createElement("div");
      row.className = "choiceRow";

      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = "correctChoice";
      radio.checked = (q.correctChoiceId === ch.id);
      radio.addEventListener("change", () => { q.correctChoiceId = ch.id; });

      const inp = document.createElement("input");
      inp.type = "text";
      inp.placeholder = `${letters[i]} choice text`;
      inp.value = ch.text ?? "";
      inp.addEventListener("input", (e) => { ch.text = e.target.value; });

      row.appendChild(radio);
      row.appendChild(inp);
      box.appendChild(row);
    });
  }

  function createQuestion(type) {
    const base = {
      id: uid("q"),
      type,
      points: "",
      prompt: "",
      images: [],
      shuffleSelected: true,
      choices: null,
      correctChoiceId: null,
      numericAnswer: "",
      infoImageScale: "0.75",
      mcColumns: 1        // NEW: 1 | 2 | 4
    };



    if (type === "multiple_choice") {
      base.choices = [
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" },
        { id: uid("c"), text: "" }
      ];
      base.correctChoiceId = base.choices[0].id;
    }

    state.questions.push(base);
    state.selectedId = base.id;
    renderList();
    loadEditor(base.id);
  }

  function saveEdits() {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q) return;

    q.type = el("qType").value;
    q.points = el("qPoints").value === "" ? "" : Number(el("qPoints").value);
    q.prompt = el("qPrompt").value;

    const imgs = el("qImages").value.split("\n").map(s => s.trim()).filter(Boolean);
    q.images = imgs;

    if (q.type === "numeric") {
      q.numericAnswer = el("numAnswer").value || "";
    }

    if (q.type === "multiple_choice") {
      clamp4Choices(q);
      const v = Number(el("mcColumns").value);
      q.mcColumns = (v === 2 || v === 4) ? v : 1;
    }



    renderList();
    loadEditor(q.id);
    saveToCache();

  }

  function deleteSelected() {
    const idx = state.questions.findIndex(x => x.id === state.selectedId);
    if (idx < 0) return;
    state.questions.splice(idx, 1);
    state.selectedId = state.questions[idx]?.id || state.questions[idx - 1]?.id || null;
    renderList();
    loadEditor(state.selectedId);
  }

  function duplicateSelected() {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q) return;

    const copy = JSON.parse(JSON.stringify(q));
    copy.id = uid("q");
    copy.shuffleSelected = true;

    if (copy.type === "multiple_choice") {
      const oldToNew = new Map();
      copy.choices.forEach(ch => {
        const oldId = ch.id;
        ch.id = uid("c");
        oldToNew.set(oldId, ch.id);
      });
      copy.correctChoiceId = oldToNew.get(copy.correctChoiceId) || copy.choices[0].id;
    }

    const idx = state.questions.findIndex(x => x.id === state.selectedId);
    state.questions.splice(idx + 1, 0, copy);
    state.selectedId = copy.id;
    renderList();
    loadEditor(copy.id);
  }

  function shuffleSelected() {
    const units = getGroupUnits(state.questions);

    const selectedUnitIndexes = [];
    const selectedUnits = [];

    units.forEach((u, idx) => {
      const isSelectedUnit = u.items.some(q => q.selected);
      if (isSelectedUnit) {
        selectedUnitIndexes.push(idx);
        selectedUnits.push(u);
      }
    });

    if (selectedUnits.length < 2) return;

    if (selectedUnits.length === 2) {
      [selectedUnits[0], selectedUnits[1]] = [selectedUnits[1], selectedUnits[0]];
    } else {
      const originalSig = selectedUnits.map(u => u.ids.join("|")).join("||");
      for (let attempt = 0; attempt < 12; attempt++) {
        shuffleArrayInPlace(selectedUnits);
        const newSig = selectedUnits.map(u => u.ids.join("|")).join("||");
        if (newSig !== originalSig) break;
      }
    }

    selectedUnitIndexes.forEach((unitPos, k) => {
      units[unitPos] = selectedUnits[k];
    });

    state.questions = units.flatMap(u => u.items);

    // Keep selections: do NOT clear q.selected
    renderList();
    loadEditor(state.selectedId);

    refreshAfterReorder();
  }


function sameOrderByUnit(unitsA, unitsB) {
  if (unitsA.length !== unitsB.length) return false;
  for (let i = 0; i < unitsA.length; i++) {
    // Compare by a stable signature; ids list is stable for the unit
    const a = unitsA[i].ids.join("|");
    const b = unitsB[i].ids.join("|");
    if (a !== b) return false;
  }
  return true;
}

function forceDifferentShuffleUnits(units) {
  if (units.length < 2) return false;

  // Make a copy to compare against
  const original = units.map(u => ({ ids: [...u.ids], items: u.items }));

  // If exactly 2, just swap for guaranteed change
  if (units.length === 2) {
    [units[0], units[1]] = [units[1], units[0]];
    return true;
  }

  // Try a few times to get a different permutation
  for (let attempt = 0; attempt < 12; attempt++) {
    shuffleArrayInPlace(units);
    if (!sameOrderByUnit(units, original)) return true;
  }

  // Extremely unlikely fallback: force a change by swapping first two
  [units[0], units[1]] = [units[1], units[0]];
  return true;
}

  function shuffleAll() {
  const units = getGroupUnits(state.questions);

  const changed = forceDifferentShuffleUnits(units);
  if (!changed) return;

  state.questions = units.flatMap(u => u.items);

  renderList();
  loadEditor(state.selectedId);

  refreshAfterReorder();
}


function shuffleWithinGroups({ onlySelectedGroups = false } = {}) {
  const units = getGroupUnits(state.questions);

  units.forEach(u => {
    const isGrouped = u.items.length > 1 && u.items[0].groupId;
    if (!isGrouped) return;

    if (onlySelectedGroups) {
      const selectedInUnit = u.items.some(q => q.selected);
      if (!selectedInUnit) return;
    }

    if (u.items.length === 2) {
      [u.items[0], u.items[1]] = [u.items[1], u.items[0]];
    } else if (u.items.length > 2) {
      const originalSig = u.items.map(x => x.id).join("|");
      for (let attempt = 0; attempt < 12; attempt++) {
        shuffleArrayInPlace(u.items);
        const newSig = u.items.map(x => x.id).join("|");
        if (newSig !== originalSig) break;
      }
    }
  });

  state.questions = units.flatMap(u => u.items);

  renderList();
  loadEditor(state.selectedId);

  refreshAfterReorder();
}



function getGroupUnits(list) {
  // Returns units: each unit is { ids: [...], items: [...] }
  // A unit is either one ungrouped question, or a contiguous group (same groupId).
  const units = [];
  let i = 0;

  while (i < list.length) {
    const q = list[i];
    if (!q.groupId) {
      units.push({ ids: [q.id], items: [q] });
      i++;
      continue;
    }

    // collect contiguous items with same groupId
    const gid = q.groupId;
    const items = [];
    const ids = [];
    let j = i;
    while (j < list.length && list[j].groupId === gid) {
      items.push(list[j]);
      ids.push(list[j].id);
      j++;
    }
    units.push({ ids, items });
    i = j;
  }

  return units;
}

function groupSelected() {
  const selected = state.questions.filter(q => q.selected);
  if (selected.length < 2) return;

  // Keep relative order as currently shown
  const selectedIds = new Set(selected.map(q => q.id));

  // Find earliest index among selected questions
  const firstIndex = state.questions.findIndex(q => selectedIds.has(q.id));

  // Remove selected from list
  const remaining = state.questions.filter(q => !selectedIds.has(q.id));

  // Insert them back contiguously at firstIndex
  remaining.splice(firstIndex, 0, ...selected);

  // Assign groupId (same for all in selection)
  const gid = uid("g");
  selected.forEach(q => { q.groupId = gid; });

  // Replace list
  state.questions = remaining;

  // Optional: uncheck after grouping (recommended)
  selected.forEach(q => { q.selected = false; });

  renderList();
  loadEditor(state.selectedId);
}

function ungroupSelected() {
  // Find any selected question that has a groupId
  const picked = state.questions.find(q => q.selected && q.groupId);
  if (!picked) return;

  const gid = picked.groupId;

  // Remove groupId from all questions in that group
  state.questions.forEach(q => {
    if (q.groupId === gid) q.groupId = null;
  });

  // Optional: clear selection
  state.questions.forEach(q => { q.selected = false; });

  renderList();
  loadEditor(state.selectedId);
}

function removeTableColumn() {
  // Keep at least 1 column
  if (tableBuilder.cols.length <= 1) return;

  tableBuilder.cols.pop();
  tableBuilder.cells.forEach(row => row.pop());
  renderTableBuilder();
}

function removeTableRow() {
  // Keep at least 1 row
  if (tableBuilder.rows.length <= 1) return;

  tableBuilder.rows.pop();
  tableBuilder.cells.pop();
  renderTableBuilder();
}


function shuffleArrayInPlace(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function groupNumberMap() {
  const map = new Map();
  let n = 1;
  state.questions.forEach(q => {
    if (q.groupId && !map.has(q.groupId)) map.set(q.groupId, n++);
  });
  return map;
}

function getAnswerLabel(q) {
  if (q.type === "multiple_choice") {
    clamp4Choices(q);
    const idx = q.choices.findIndex(c => c.id === q.correctChoiceId);
    return ["A","B","C","D"][Math.max(0, idx)];
  }
  if (q.type === "numeric") {
    return (q.numericAnswer && q.numericAnswer.trim()) ? q.numericAnswer.trim() : "(no answer)";
  }
  return "(written)";
}

function saveKeySnapshot() {
  if (!state.questions.length) return;

  const name = prompt("Name this key snapshot (e.g., Version A) :", `Key ${state.savedKeys.length + 1}`);
  if (name === null) return;

  const snapshot = {
    id: uid("key"),
    name: (name || `Key ${state.savedKeys.length + 1}`).trim(),
    createdAt: new Date().toISOString(),
    order: state.questions.map(q => q.id),
    info: state.questions.map((q, idx) => ({
    qid: q.id,
    originalIndex: idx,                 // keep raw position for internal tracking
    originalLabel: getDisplayedLabelAtIndex(idx),  // Q# or INFO
    type: q.type,
    groupId: q.groupId || null,
    answer: (q.type === "info") ? "—" : getAnswerLabel(q),
    promptPreview: (q.prompt || "").replace(/\s+/g, " ").trim().slice(0, 60)
  }))

  };

  state.savedKeys.unshift(snapshot);
  renderShuffleMap(snapshot.id);
}

function latestSnapshotId() {
  return state.savedKeys.length ? state.savedKeys[0].id : null;
}

function renderShuffleMap(snapshotId = null) {
  const out = el("shuffleMapOut");
  if (!state.savedKeys.length) {
    out.innerHTML = `<div class="small muted">No saved key snapshots yet.</div>`;
    return;
  }

  const snap = snapshotId
    ? state.savedKeys.find(s => s.id === snapshotId)
    : state.savedKeys[0];

  if (!snap) {
    out.innerHTML = `<div class="small muted">Snapshot not found.</div>`;
    return;
  }




  // Build current index lookup: qid -> current index (0-based)
  const currentIndex = new Map();
  state.questions.forEach((q, idx) => currentIndex.set(q.id, idx));

  // Build group numbering map (nice display)
  const gmap = groupNumberMap();

  const rows = snap.info.map(item => {
    const nowIdx = currentIndex.get(item.qid);
    const isMissing = (nowIdx === undefined);

    const nowLabel = isMissing ? "(deleted)" : getDisplayedLabelAtIndex(nowIdx);

    // moved: label changed (Q# changes) — this ignores INFO counting as a question
    const moved = !isMissing && nowLabel !== item.originalLabel;

    const groupLabel = item.groupId ? `GROUP ${gmap.get(item.groupId) || "?"}` : "";

    return `<tr>
      <td>${item.originalLabel}</td>
      <td>${isMissing ? `<span class="muted">(deleted)</span>` : nowLabel}</td>
      <td>${item.type.replace("_"," ")}</td>
      <td>${groupLabel}</td>
      <td>${item.answer}</td>
      <td>${item.promptPreview}${(item.promptPreview || "").length >= 60 ? "…" : ""}</td>
      <td>${isMissing ? "—" : (moved ? "Moved" : "Same")}</td>
    </tr>`;
  }).join("");

  out.innerHTML = `
    <div class="small muted" style="margin-bottom:8px;">
      Snapshot: <b>${snap.name}</b> • Saved: ${new Date(snap.createdAt).toLocaleString()}
    </div>
    <table>
      <thead>
        <tr>
          <th>Original #</th>
          <th>Current #</th>
          <th>Type</th>
          <th>Group</th>
          <th>Answer</th>
          <th>Prompt (preview)</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody>${rows}</tbody>
    </table>
  `;
}



// ----------------------
// LocalStorage persistence
// ----------------------
const STORAGE_KEY = "exam_builder_state_v1";

function saveToCache() {
  try {
    const payload = {
      version: 1,
      savedAt: new Date().toISOString(),
      state: {
        questions: state.questions,
        selectedId: state.selectedId
      },
      meta: {
        testName: el("testName")?.value ?? "",
        gradeSubject: el("gradeSubject")?.value ?? "",
        headerImage: el("headerImage")?.value ?? "",
        instructions: el("instructions")?.value ?? ""
      }
    };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
  } catch (e) {
    console.error("Failed to save to cache:", e);
  }
}

function loadFromCache() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return false;

    const payload = JSON.parse(raw);
    if (!payload || !payload.state) return false;

    // Restore state
    state.questions = payload.state.questions || [];
    state.selectedId = payload.state.selectedId || null;

    // Restore form fields
    if (payload.meta) {
      if (el("testName")) el("testName").value = payload.meta.testName || "";
      if (el("gradeSubject")) el("gradeSubject").value = payload.meta.gradeSubject || "";
      if (el("headerImage")) el("headerImage").value = payload.meta.headerImage || "";
      if (el("instructions")) el("instructions").value = payload.meta.instructions || "";
    }

    return true;
  } catch (e) {
    console.error("Failed to load from cache:", e);
    return false;
  }
}

function clearCache() {
  localStorage.removeItem(STORAGE_KEY);
}





// ----------------------
// Table Builder (MC matrix)
// ----------------------
const tableBuilder = {
  cols: ["Column 1", "Column 2", "Column 3", "Column 4"],
  rows: ["A.", "B.", "C.", "D."],
  // cells[r][c] is the cell text for row r, column c
  cells: [
    ["", "", "", ""],
    ["", "", "", ""],
    ["", "", "", ""],
    ["", "", "", ""]
  ]
};

function openTableModal() {
  el("tableModal").style.display = "block";
  renderTableBuilder();
}

function closeTableModal() {
  el("tableModal").style.display = "none";
}

function ensureTableDimensions() {
  // Ensure each row has correct column count
  tableBuilder.cells.forEach((row, r) => {
    while (row.length < tableBuilder.cols.length) row.push("");
    if (row.length > tableBuilder.cols.length) row.length = tableBuilder.cols.length;
  });
}

function addTableColumn() {
  tableBuilder.cols.push(`Column ${tableBuilder.cols.length + 1}`);
  tableBuilder.cells.forEach(row => row.push(""));
  renderTableBuilder();
}

function addTableRow() {
  const nextLetter = String.fromCharCode("A".charCodeAt(0) + tableBuilder.rows.length);
  tableBuilder.rows.push(`${nextLetter}.`);
  tableBuilder.cells.push(Array(tableBuilder.cols.length).fill(""));
  renderTableBuilder();
}

function renderTableBuilder() {
  ensureTableDimensions();

  const host = el("tableBuilderHost");
  const table = document.createElement("table");
  table.className = "tb-grid";
  table.style.width = "100%";
  table.style.borderCollapse = "collapse";

  // Header row
  const thead = document.createElement("thead");
  const hr = document.createElement("tr");

  const corner = document.createElement("th");
  corner.textContent = "";
  corner.style.border = "1px solid #24324a";
  corner.style.padding = "6px 8px";
  hr.appendChild(corner);

  tableBuilder.cols.forEach((h, c) => {
    const th = document.createElement("th");
    th.style.border = "1px solid #24324a";
    th.style.padding = "6px 8px";

    const inp = document.createElement("input");
    inp.type = "text";
    inp.value = h;
    inp.addEventListener("input", (e) => {
      tableBuilder.cols[c] = e.target.value;
    });
    th.appendChild(inp);
    hr.appendChild(th);
  });

  thead.appendChild(hr);
  table.appendChild(thead);

  // Body rows
  const tbody = document.createElement("tbody");
  tableBuilder.rows.forEach((label, r) => {
    const tr = document.createElement("tr");

    const rowLabel = document.createElement("td");
    rowLabel.style.border = "1px solid #24324a";
    rowLabel.style.padding = "6px 8px";
    rowLabel.style.whiteSpace = "nowrap";

    const inpLabel = document.createElement("input");
    inpLabel.type = "text";
    inpLabel.value = label;
    inpLabel.addEventListener("input", (e) => {
      tableBuilder.rows[r] = e.target.value;
    });

    rowLabel.appendChild(inpLabel);
    tr.appendChild(rowLabel);

    tableBuilder.cols.forEach((_, c) => {
      const td = document.createElement("td");
      td.style.border = "1px solid #24324a";
      td.style.padding = "6px 8px";

      const inp = document.createElement("input");
      inp.type = "text";
      inp.value = tableBuilder.cells[r][c] ?? "";
      inp.addEventListener("input", (e) => {
        tableBuilder.cells[r][c] = e.target.value;
      });

      td.appendChild(inp);
      tr.appendChild(td);
    });

    tbody.appendChild(tr);
  });

  table.appendChild(tbody);

  host.innerHTML = "";
  host.appendChild(table);
}

function latexEscapeCell(s) {
  // Minimal escaping so tabular doesn't break. Teachers can still type LaTeX if needed.
  // Key: escape & which would split columns.
  return (s ?? "").replaceAll("&", "\\&");
}

function buildLatexTable() {
  ensureTableDimensions();

  // Column spec: first column is left-aligned, others centered
  const colSpec = "|l|" + tableBuilder.cols.map(() => "c|").join("");

  const header = ` & ${tableBuilder.cols.map(latexEscapeCell).join(" & ")} \\\\ \\hline`;

  const rows = tableBuilder.rows.map((lab, r) => {
    const cells = tableBuilder.cells[r].map(latexEscapeCell).join(" & ");
    return `${latexEscapeCell(lab)} & ${cells} \\\\ \\hline`;
  }).join("\n");

  return [
    "\\begin{center}",
    "\\renewcommand{\\arraystretch}{1.3}",
    `\\begin{tabular}{${colSpec}}`,
    "\\hline",
    header,
    rows,
    "\\end{tabular}",
    "\\end{center}"
  ].join("\n");
}

function latexBlockHeader(q) {
  // sentinel comment for robust importing + needspace for page-breaking control
  return [
    `%==QBLOCK id=${q.id}==`,
    `\\Needspace{8\\baselineskip}`
  ].join("\n");
}

function insertTableLatex() {
  const target = el("tableInsertTarget").value;
  const latex = buildLatexTable();

  const q = state.questions.find(x => x.id === state.selectedId);
  if (!q) return;

  if (target === "prompt") {
    const ta = el("qPrompt");
    const start = ta.selectionStart ?? ta.value.length;
    const end = ta.selectionEnd ?? ta.value.length;
    ta.value = ta.value.slice(0, start) + "\n" + latex + "\n" + ta.value.slice(end);
    q.prompt = ta.value;
    return;
  }

  if (q.type !== "multiple_choice") return;
  clamp4Choices(q);

  const idx = Number(target.replace("choice", ""));
  if (Number.isNaN(idx) || idx < 0 || idx > 3) return;

  q.choices[idx].text = (q.choices[idx].text || "") + "\n" + latex;

  loadEditor(q.id);
}

  // ----------------------
// Graph Builder (Function Plot)
// ----------------------
function openGraphModal() {
  el("graphModal").style.display = "block";
}

function closeGraphModal() {
  el("graphModal").style.display = "none";
}

function buildGraphLatex() {
  const xmin = Number(el("gXMin").value);
  const xmax = Number(el("gXMax").value);
  const ymin = Number(el("gYMin").value);
  const ymax = Number(el("gYMax").value);
  const step = Number(el("gStep").value);
  const func = (el("gFunc").value || "").trim();

  // NEW: scale
  const scaleRaw = (el("gScale")?.value ?? "1").toString().trim();
  const scale = Number(scaleRaw);

  if (!Number.isFinite(xmin) || !Number.isFinite(xmax) ||
      !Number.isFinite(ymin) || !Number.isFinite(ymax) ||
      !Number.isFinite(step)) {
    alert("Please enter valid numeric bounds and step.");
    return "";
  }

  if (!func) {
    alert("Please enter a function.");
    return "";
  }

  if (!Number.isFinite(scale) || scale <= 0) {
    alert("Please enter a valid scale (e.g., 1, 0.8, 1.2).");
    return "";
  }

  // NOTE: now 7 args, last one is scale
  return `\\drawfunction{${xmin}}{${xmax}}{${ymin}}{${ymax}}{${step}}{${escapeLatexUnsafe(func)}}{${scale}}`;
}


function insertGraphLatex() {
  const q = state.questions.find(x => x.id === state.selectedId);
  if (!q) return;

  const target = el("graphInsertTarget").value;
  const latex = buildGraphLatex();
  if (!latex) return;

  // Insert into PROMPT (works for MC, Numeric, Written, Info)
  if (target === "prompt") {
    const ta = el("qPrompt");
    const start = ta.selectionStart ?? ta.value.length;
    const end = ta.selectionEnd ?? ta.value.length;

    ta.value =
      ta.value.slice(0, start) +
      "\n" + latex + "\n" +
      ta.value.slice(end);

    q.prompt = ta.value;

    closeGraphModal();
    loadEditor(q.id);
    return;
  }

  // Insert into MC choice ONLY
  if (q.type !== "multiple_choice") {
    alert("Choice targets only work for Multiple Choice questions.");
    return;
  }

  clamp4Choices(q);

  const idx = Number(target.replace("choice", ""));
  if (Number.isNaN(idx) || idx < 0 || idx > 3) return;

  q.choices[idx].text = (q.choices[idx].text || "") + "\n" + latex;

  closeGraphModal();
  loadEditor(q.id);
}


 function latexQuestionBlock(q) {
  const pts =
    (q.points !== "" && q.points !== null && q.points !== undefined)
      ? `[${q.points}] `
      : " ";

  const imgLines = (q.images || []).map(fn =>
    `\\begin{center}\n\\includegraphics{${escapeLatexUnsafe(fn)}}\n\\end{center}\n`
  ).join("");

  // INFO items (not questions)
  if (q.type === "info") {
    const scale = (q.infoImageScale || "0.75").trim() || "0.75";
    const imgs = (q.images || []).map(fn =>
      `\\includegraphics[scale=${scale}]{${escapeLatexUnsafe(fn)}}`
    ).join("\n");

    const innerInfo = [
      `\\begin{tcolorbox}[colback=white]`,
      `\\begin{center}`,
      escapeLatexUnsafe(q.prompt || ""),
      imgs ? imgs : "",
      `\\end{center}`,
      `\\end{tcolorbox}`
    ].filter(Boolean).join("\n");

    return [
      latexBlockHeader(q),
      innerInfo,
      ``
    ].join("\n");


  }

    // MULTIPLE CHOICE
  if (q.type === "multiple_choice") {
    clamp4Choices(q);

    const choiceLines = q.choices.map(ch => {
      const cmd = (ch.id === q.correctChoiceId) ? "\\CorrectChoice" : "\\choice";
      return `    ${cmd} ${escapeLatexUnsafe(ch.text)}`.trimEnd();
    }).join("\n");

    // Ensure numeric comparison works even if loaded from storage as string
    const cols = Number(q.mcColumns || 1);

    let choicesBody = choiceLines;
    if (cols === 2 || cols === 4) {
      choicesBody = [
        `\\begin{multicols}{${cols}}`,
        choiceLines,
        `\\end{multicols}`
      ].join("\n");
    }

    const innerMC = [
      imgLines,
      `\\question${pts}${escapeLatexUnsafe(q.prompt)}`,
      `\\begin{choices}`,
      choicesBody,
      `\\end{choices}`
    ].filter(Boolean).join("\n");

    return [
      latexBlockHeader(q),
      innerMC,
      ``
    ].join("\n");
  }


  // NUMERIC
  if (q.type === "numeric") {
    const ans = (q.numericAnswer || "").trim();

    const innerNum = [
      imgLines,
      `\\question${pts}${escapeLatexUnsafe(q.prompt)}`,
      `\\numbox`,
      ans ? `\\ifprintanswers\n\\textbf{Answer:} ${escapeLatexUnsafe(ans)}\n\\fi` : ``
    ].filter(Boolean).join("\n");

    return [
      latexBlockHeader(q),
      innerNum,
      ``
    ].join("\n");

  }

  // WRITTEN (default)
  const innerWritten = [
    imgLines,
    `\\question${pts}${escapeLatexUnsafe(q.prompt)}`
  ].filter(Boolean).join("\n");

  return [
    latexBlockHeader(q),
    innerWritten,
    ``
  ].join("\n");

}

function stripLatexNoise(s) {
  return (s || "")
    .replace(/\r/g, "")
    .replace(/^\s+|\s+$/g, "");
}

function extractAllIncludeGraphics(block) {
  const imgs = [];
  // matches \includegraphics{file} and \includegraphics[...]{file}
  const re = /\\includegraphics(?:\[[^\]]*?\])?\{([^}]+)\}/g;
  let m;
  while ((m = re.exec(block)) !== null) {
    const fn = stripLatexNoise(m[1]);
    if (fn) imgs.push(fn);
  }
  return imgs;
}

function extractPoints(block) {
  // \question[3] or \question[3.5]
  const m = block.match(/\\question\s*\[([0-9]+(?:\.[0-9]+)?)\]/);
  return m ? Number(m[1]) : "";
}

function extractQuestionPrompt(block) {
  // Grab text after \question[pts] or \question up to newline or \begin{choices} or \numbox
  // This is intentionally conservative and assumes your generator puts prompt on same line.
  const m = block.match(/\\question(?:\s*\[[^\]]*\])?\s*([^\n]*)/);
  return m ? stripLatexNoise(m[1]) : "";
}

function extractChoices(block) {
  const choices = [];
  let correctIndex = 0;

  // isolate inside choices environment
  const env = block.match(/\\begin\{choices\}([\s\S]*?)\\end\{choices\}/);
  if (!env) return { choices, correctIndex };

  const lines = env[1].split("\n").map(x => x.trim()).filter(Boolean);

  for (const line of lines) {
    const mc = line.match(/^\\CorrectChoice\s*(.*)$/);
    const ch = line.match(/^\\choice\s*(.*)$/);

    if (mc) {
      correctIndex = choices.length;
      choices.push(stripLatexNoise(mc[1]));
    } else if (ch) {
      choices.push(stripLatexNoise(ch[1]));
    }
  }

  // enforce 4 choices like your builder expects
  while (choices.length < 4) choices.push("");
  if (choices.length > 4) choices.length = 4;

  return { choices, correctIndex };
}

function extractNumericAnswer(block) {
  // looks for \textbf{Answer:} ... inside \ifprintanswers ... \fi
  const m = block.match(/\\textbf\{Answer:\}\s*([^\n\\]+)[\s\S]*?\\fi/);
  return m ? stripLatexNoise(m[1]) : "";
}

function inferInfoImageScale(block) {
  // tries to pick scale from \includegraphics[scale=0.75]{...}
  const m = block.match(/\\includegraphics\[\s*scale\s*=\s*([0-9]*\.?[0-9]+)\s*\]\{/);
  return m ? stripLatexNoise(m[1]) : "0.75";
}

function extractInfoPrompt(block) {
  // try to capture what your generator emits inside center, before includegraphics.
  // We’ll take the first non-command text line inside the center environment.
  const center = block.match(/\\begin\{center\}([\s\S]*?)\\end\{center\}/);
  if (!center) return "";

  const raw = center[1]
    // remove includegraphics lines
    .replace(/\\includegraphics[\s\S]*?\}\s*/g, "")
    // remove obvious env commands
    .replace(/\\(begin|end)\{[^\}]+\}/g, "")
    .trim();

  // Keep first meaningful line
  const lines = raw.split("\n").map(x => x.trim()).filter(Boolean);
  return lines.length ? lines[0] : "";
}

function parseQuestionsFromLatex(latex) {
  const src = (latex || "").replace(/\r/g, "");
  const blocks = [];

  // split into QBLOCK blocks (recommended, robust)
const parts = src.split(/^\s*%==QBLOCK\b/m);

// parts[0] is anything before the first block; ignore it
for (let i = 1; i < parts.length; i++) {
  const chunk = parts[i];

  // First line looks like: " id=q_xxx=="
  const firstLine = (chunk.split("\n")[0] || "").trim();
  const idMatch = firstLine.match(/id=([^\s=]+)==/);
  const blockId = idMatch ? idMatch[1] : uid("q");

  const cleaned = chunk.replace(/^[^\n]*\n/, ""); // drop header line
  const b = cleaned.trim();
  if (b) blocks.push({ id: blockId, body: b });
}



  const questions = [];

for (const entry of blocks) {
  const block = entry.body.trim();

  // classify
  const isInfo = /\\begin\{tcolorbox\}/.test(block);
  const isMC = /\\begin\{choices\}/.test(block);
  const isNumeric = /\\numbox/.test(block);

  const q = {
    id: entry.id,              // IMPORTANT: keep the ID from the QBLOCK header
    type: "written",
    points: "",
    prompt: "",
    images: [],
    shuffleSelected: true,
    choices: null,
    correctChoiceId: null,
    numericAnswer: "",
    infoImageScale: "0.75",
    selected: false,
    groupId: null,
    mcColumns: 1,
  };

  // images
  const imgs = extractAllIncludeGraphics(block);

  if (isInfo) {
    q.type = "info";
    q.prompt = extractInfoPrompt(block);
    q.images = imgs;
    q.infoImageScale = inferInfoImageScale(block);
    q.points = "";
  } else if (isMC) {
    q.type = "multiple_choice";
    q.points = extractPoints(block);
    q.prompt = extractQuestionPrompt(block);
    q.images = imgs;

    const { choices, correctIndex } = extractChoices(block);
    q.choices = choices.map(text => ({ id: uid("c"), text }));
    q.correctChoiceId = q.choices[Math.max(0, Math.min(3, correctIndex))].id;
  } else if (isNumeric) {
    q.type = "numeric";
    q.points = extractPoints(block);
    q.prompt = extractQuestionPrompt(block);
    q.images = imgs;
    q.numericAnswer = extractNumericAnswer(block);
  } else {
    q.type = "written";
    q.points = extractPoints(block);
    q.prompt = extractQuestionPrompt(block);
    q.images = imgs;
  }

  questions.push(q);
}

return questions;

}


  function generateLatex() {
  const mode = (el("docMode")?.value || "test"); // "test" or "quiz"

  const testName = el("testName")?.value || "TITLE GOES HERE";
  const gradeSubject = el("gradeSubject")?.value || "Grade and Subject goes here";
  const headerImage = el("headerImage")?.value || "Stem Header.png";

  const instructionsLines = (el("instructions")?.value || "")
    .split("\n")
    .map(s => s.trim())
    .filter(Boolean);

  const instructionItems = instructionsLines.length
    ? instructionsLines.map(x => `       \\item ${escapeLatexUnsafe(x)}`).join("\n")
    : `       \\item Put your test rules in here eg.\n       \\item No Calculators`;

  // Build question blocks from your current question list
  const questionsLatex = state.questions.map(q => latexQuestionBlock(q)).join("\n");

  let out = "";

  if (mode === "quiz") {
    // QUIZ FORMAT (compact header)
    out =
`\\documentclass[10pt]{exam}
\\usepackage{tikz}
\\usepackage{amsmath, amssymb}
\\usepackage[margin=1in]{geometry}
\\usepackage{tikz-3dplot} % For 3D projections
\\tdplotsetmaincoords{70}{110}
\\usepackage{multicol}
\\usepackage{graphicx}
\\usepackage{pgfplots}
\\usepackage{needspace}

\\graphicspath{ {./images/} }
\\usepackage{tcolorbox}
\\pointsinmargin

\\def\\numbox{
\\begin{center}
\\begin{tikzpicture}
\\draw (0,0) rectangle (1,1);
\\draw (0,0) rectangle (2,1);
\\draw (0,0) rectangle (3,1);
\\draw (0,0) rectangle (4,1);
\\end{tikzpicture}
\\end{center}
}

% Function plot helper (requires pgfplots)
\\def\\drawfunction#1#2#3#4#5#6#7{%
\\begin{tikzpicture}[scale=#7]
\\begin{axis}[
    axis lines = center,
    xmin = #1, xmax = #2,
    ymin = #3, ymax = #4,
    grid = both,
    major grid style = {line width=0.8pt, gray!60},
    minor grid style = {line width=0.4pt, gray!30},
    xlabel = $x$,
    ylabel = $y$,
    samples = 200,
    xtick distance = #5,
    ytick distance = #5
]
\\addplot[thick, black] {#6};
\\end{axis}
\\end{tikzpicture}
}


\\begin{document}

\\begin{center}
  \\textbf{\\Large ${escapeLatexUnsafe(testName)}}
\\end{center}
\\vspace{0.5cm}
Name: \\underline{\\hspace{6cm}} \\hspace{5cm} Date: \\underline{\\hspace{4cm}}
\\vspace{1cm}

% Questions go in here. use the format \\question[# of points] Question text here
\\begin{questions}
${questionsLatex}
\\end{questions}

\\end{document}
`;
  } else {
    // TEST FORMAT (your current full title page)
    out =
`\\documentclass[10pt, addpoints]{exam}
\\addpoints
\\usepackage{amsmath}
\\usepackage{tikz}
\\usepackage{pgfplots}
\\usepackage{multicol}
\\usepackage{tcolorbox}
\\usepackage{graphicx}
\\graphicspath{ {./images/} }
\\pointsinmargin

\\usepackage{needspace}
\\usepackage{etoolbox}

\\def\\numbox{
\\begin{center}
\\begin{tikzpicture}
\\draw (0,0) rectangle (1,1);
\\draw (0,0) rectangle (2,1);
\\draw (0,0) rectangle (3,1);
\\draw (0,0) rectangle (4,1);
\\end{tikzpicture}
\\end{center}
}


% Function plot helper (requires pgfplots)
\\def\\drawfunction#1#2#3#4#5#6#7{%
\\begin{tikzpicture}[scale=#7]
\\begin{axis}[
    axis lines = center,
    xmin = #1, xmax = #2,
    ymin = #3, ymax = #4,
    grid = both,
    major grid style = {line width=0.8pt, gray!60},
    minor grid style = {line width=0.4pt, gray!30},
    xlabel = $x$,
    ylabel = $y$,
    samples = 200,
    xtick distance = #5,
    ytick distance = #5
]
\\addplot[thick, black] {#6};
\\end{axis}
\\end{tikzpicture}
}


\\begin{document}

% Title Page
\\begin{center}

    \\vspace{2cm}
    \\includegraphics{${escapeLatexUnsafe(headerImage)}}

\\vspace{1cm}
    \\Huge\\textbf{${escapeLatexUnsafe(testName)}}

    \\vspace{1cm}
    \\large\\textbf{${escapeLatexUnsafe(gradeSubject)}}

    \\vspace{2cm}
    \\large
    \\begin{tabbing}
    Name: \\underline{\\hspace{8cm}} \\\\
    Date: \\underline{\\hspace{8cm}}
    \\end{tabbing}

    \\vspace{1cm}
    \\textbf{Instructions:}
    \\vspace{0.5cm}

    \\begin{itemize}
${instructionItems}
    \\end{itemize}

\\vspace{1cm}
 \\begin{center}
    \\fbox{\\textbf{Total Points for this Exam: \\numpoints}}
\\end{center}

\\end{center}

\\newpage
\\begin{center} \\textbf{ Multiple Choice} \\end{center}

\\begin{questions}

% Questions go here.
${questionsLatex}
\\end{questions}

\\end{document}
`;
  }

  el("latexOut").value = out;
  renderMapping();
}


  function renderMapping() {
    const container = el("mappingOut");
    if (!state.questions.length) {
      container.innerHTML = `<div class="small muted">No questions.</div>`;
      return;
    }

      let qNum = 0;
  const rows = state.questions.map((q) => {
    let label = "";
    let ans = "";

    if (q.type === "info") {
      label = "INFO";
      ans = "—";
    } else {
      qNum++;
      label = "Q" + qNum;

      if (q.type === "multiple_choice") {
        clamp4Choices(q);
        const idx = q.choices.findIndex(c => c.id === q.correctChoiceId);
        ans = ["A","B","C","D"][Math.max(0, idx)];
      } else if (q.type === "numeric") {
        ans = (q.numericAnswer && q.numericAnswer.trim()) ? q.numericAnswer.trim() : "(no answer)";
      } else {
        ans = "(written)";
      }
    }

    const promptPreview = (q.prompt || "").replace(/\s+/g, " ").trim().slice(0, 60);

    return `<tr>
      <td>${label}</td>
      <td>${q.type.replace("_"," ")}</td>
      <td>${promptPreview}${(q.prompt||"").length>60?"…":""}</td>
      <td>${ans}</td>
    </tr>`;
  }).join("");


    container.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>Rendered #</th>
            <th>Type</th>
            <th>Prompt (preview)</th>
            <th>Answer (MC)</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  function refreshAfterReorder() {
    // Update the right-side mapping panel
    renderMapping();

    // If a snapshot exists, update the shuffle tracking panel too
    const sid = latestSnapshotId();
    if (sid) renderShuffleMap(sid);

    // Optional but recommended: persist order changes
    saveToCache();
  }

  async function copyLatex() {
    const txt = el("latexOut").value;
    if (!txt) return;
    await navigator.clipboard.writeText(txt);
    el("btnCopy").textContent = "Copied";
    setTimeout(() => el("btnCopy").textContent = "Copy LaTeX", 900);
  }

  // Buttons
  el("btnAddMC").addEventListener("click", () => createQuestion("multiple_choice"));
  el("btnAddNum").addEventListener("click", () => createQuestion("numeric"));
  el("btnAddWritten").addEventListener("click", () => createQuestion("written"));

  el("btnSave").addEventListener("click", saveEdits);
  el("btnDelete").addEventListener("click", deleteSelected);
  el("btnDuplicate").addEventListener("click", duplicateSelected);
  el("btnShuffleSelected").addEventListener("click", shuffleSelected);
  el("btnShuffleAll").addEventListener("click", shuffleAll);
  el("btnGenerate").addEventListener("click", generateLatex);
  el("btnCopy").addEventListener("click", copyLatex);
  el("btnGroupSelected").addEventListener("click", groupSelected);
  el("btnUngroupSelected").addEventListener("click", ungroupSelected);
  el("btnShuffleWithinGroups").addEventListener("click", () => shuffleWithinGroups());

  el("btnAddInfo").addEventListener("click", () => createQuestion("info"));

  el("mcColumns").addEventListener("change", () => {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q || q.type !== "multiple_choice") return;

    const v = Number(el("mcColumns").value);
    q.mcColumns = (v === 2 || v === 4) ? v : 1;
  });

  // Table Builder wiring
  el("btnOpenTableBuilder").addEventListener("click", openTableModal);

  el("btnCloseTableModal").addEventListener("click", closeTableModal);
  el("btnAddTableCol").addEventListener("click", addTableColumn);
  el("btnAddTableRow").addEventListener("click", addTableRow);
  el("btnRemoveTableCol").addEventListener("click", removeTableColumn);
  el("btnRemoveTableRow").addEventListener("click", removeTableRow);
  el("btnInsertTableLatex").addEventListener("click", () => {
    insertTableLatex();
    closeTableModal();
  });



  el("qType").addEventListener("change", () => {
    const q = state.questions.find(x => x.id === state.selectedId);
    if (!q) return;
    q.type = el("qType").value;
    if (q.type === "multiple_choice") clamp4Choices(q);
    loadEditor(q.id);
    renderList();
  });

  el("btnClearSaved").addEventListener("click", () => {
  clearCache();
  // Optional: also clear current session
  state.questions = [];
  state.selectedId = null;
  renderList();
  loadEditor(null);
  });

  el("btnSaveKey").addEventListener("click", saveKeySnapshot);
  el("btnShowShuffleMap").addEventListener("click", () => {
  const sid = latestSnapshotId();
  if (!sid) return;
  renderShuffleMap(sid);
  });

  // Graph Builder wiring
  el("btnOpenGraphBuilder").addEventListener("click", openGraphModal);
  el("btnCloseGraphModal").addEventListener("click", closeGraphModal);
  el("btnInsertGraphLatex").addEventListener("click", insertGraphLatex);


    // HOME / IMPORT wiring
  el("btnGoNew").addEventListener("click", () => {
    // Start fresh
    state.questions = [];
    state.selectedId = null;
    saveToCache();
    renderList();
    loadEditor(null);
    showBuilder();
  });

  el("btnGoImport").addEventListener("click", () => {
    el("importArea").style.display = "block";
  });

  el("btnCancelImport").addEventListener("click", () => {
    el("importArea").style.display = "none";
    el("importLatex").value = "";
  });

  el("btnDoImport").addEventListener("click", () => {
    const latex = el("importLatex").value || "";
    const parsed = parseQuestionsFromLatex(latex);

    if (!parsed.length) {
      alert("No questions found. Ensure the pasted LaTeX includes %==QBLOCK id=...== markers generated by this tool.");
      return;
    }

  state.questions = parsed;
  state.selectedId = parsed[0].id;

  renderList();
  loadEditor(state.selectedId);
  saveToCache();

  // clear import UI
  el("importLatex").value = "";
  el("importArea").style.display = "none";

  showBuilder();
});

  // Drag-and-drop reorder
  new Sortable(el("qList"), {
  draggable: ".qcard, .qgroup",
  handle: ".handle",
  animation: 150,

  onEnd: () => {
    // Rebuild state.questions based on the DOM order after drag.
    const list = el("qList");

    const byId = new Map(state.questions.map(q => [q.id, q]));
    const rebuilt = [];

    [...list.children].forEach(node => {
      if (node.classList.contains("qcard")) {
        const id = node.dataset.id;
        const q = byId.get(id);
        if (q) rebuilt.push(q);
        return;
      }

      if (node.classList.contains("qgroup")) {
        const cards = node.querySelectorAll(".qcard");
        cards.forEach(card => {
          const id = card.dataset.id;
          const q = byId.get(id);
          if (q) rebuilt.push(q);
        });
      }
    });

    // Only commit if we rebuilt the full list
    if (rebuilt.length === state.questions.length) {
      state.questions = rebuilt;
    }

    renderList();
    loadEditor(state.selectedId);
    refreshAfterReorder();
  }
});


loadFromCache();
renderList();

if (state.questions.length) {
  // Resume existing work
  showBuilder();
  if (state.selectedId) {
    loadEditor(state.selectedId);
  } else if (state.questions[0]) {
    state.selectedId = state.questions[0].id;
    loadEditor(state.selectedId);
  }
} else {
  // Fresh start
  showHome();
}


})();

</script>
</body>
</html>
